<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriswsq.github.io</id>
    <title>chris&apos;wang</title>
    <updated>2020-12-14T07:59:06.500Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriswsq.github.io"/>
    <link rel="self" href="https://chriswsq.github.io/atom.xml"/>
    <subtitle>当你觉得无所事事时，那你就是在虚度光阴</subtitle>
    <logo>https://chriswsq.github.io/images/avatar.png</logo>
    <icon>https://chriswsq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chris&apos;wang</rights>
    <entry>
        <title type="html"><![CDATA[docker-compose启动quorum、tessera、cakeshop]]></title>
        <id>https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/</id>
        <link href="https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/">
        </link>
        <updated>2020-12-14T07:09:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker-compose文件">docker-compose文件</h2>
<pre><code class="language-yml">version: &quot;3.6&quot;
x-quorum-def:
  &amp;quorum-def
  restart: &quot;on-failure&quot;
  image: quorumengineering/quorum:20.10.0
  expose:
    - &quot;21000&quot;
    - &quot;50000&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy&quot;, &quot;off&quot;, &quot;http://localhost:22000&quot;]
    interval: 3s
    timeout: 3s
    retries: 10
    start_period: 5s
  labels:
    com.quorum.consensus: raft
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/dd
      cat $${DDIR}/static-nodes.json
      GENESIS_FILE=&quot;$${DDIR}/genesis.json&quot;
      NETWORK_ID=$$(cat $${GENESIS_FILE} | grep chainId | awk -F &quot; &quot; '{print $$2}' | awk -F &quot;,&quot; '{print $$1}')
      geth --datadir $${DDIR} init $${GENESIS_FILE}
      geth \
        --identity node1-raft \
        --datadir $${DDIR} \
        --permissioned \
        --nodiscover \
        --verbosity 5 \
        --networkid $${NETWORK_ID} \
        --rpc \
        --raft \
        --raftport 50000 \
        --rpcaddr 0.0.0.0 \
        --rpcport 22000 \
        --rpcapi admin,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \
        --port 21000 \
        --unlock 0 \
        --allow-insecure-unlock \
        --nousb \
        --password $${DDIR}/passwords.txt \
x-tx-manager-def:
  &amp;tx-manager-def
  image: quorumengineering/tessera:20.10.0
  expose:
    - &quot;9000&quot;
    - &quot;9080&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD-SHELL&quot;, &quot;[ -S /qdata/tm/tm.ipc ] || exit 1&quot;]
    interval: 3s
    timeout: 3s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      if [ &quot;$${PRIVATE_CONFIG}&quot; == &quot;ignore&quot; ]; then
        /bin/true
        exit 0
      fi
      DDIR=/qdata/tm
      mkdir -p $${DDIR}
          #extract the tessera version from the jar
          TESSERA_VERSION=$$(unzip -p /tessera/tessera-app.jar META-INF/MANIFEST.MF | grep Tessera-Version | cut -d&quot; &quot; -f2)
          #generating the two config flavors
          cat &lt;&lt;EOF &gt; $${DDIR}/tessera-config.json
          {
            &quot;useWhiteList&quot;: false,
            &quot;jdbc&quot;: {
              &quot;username&quot;: &quot;sa&quot;,
              &quot;password&quot;: &quot;&quot;,
              &quot;url&quot;: &quot;jdbc:h2:./$${DDIR}/db;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
              &quot;autoCreateTables&quot;: true
            },
            &quot;serverConfigs&quot;:[
            {
              &quot;app&quot;:&quot;ThirdParty&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9080&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;Q2T&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;unix:$${DDIR}/tm.ipc&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;P2P&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9000&quot;,
              &quot;sslConfig&quot;: {
                &quot;tls&quot;: &quot;OFF&quot;
              },
              &quot;communicationType&quot; : &quot;REST&quot;
            }
            ],
            &quot;peer&quot;: [
               {
                   &quot;url&quot;: &quot;http://192.168.40.6:9000&quot;
               },
               {
                   &quot;url&quot;: &quot;http://192.168.40.7:9000&quot;
               }
            ],
            &quot;keys&quot;: {
              &quot;passwords&quot;: [],
              &quot;keyData&quot;: [
                {
                  &quot;config&quot;: $$(cat $${DDIR}/tm.key),
                  &quot;publicKey&quot;: &quot;$$(cat $${DDIR}/tm.pub)&quot;
                }
              ]
            },
            &quot;alwaysSendTo&quot;: []
          }
      EOF
          cat $${DDIR}/tessera-config.json
          java -Xms128M -Xmx128M -jar /tessera/tessera-app.jar -configfile $${DDIR}/tessera-config.json
x-cakeshop-def:
  &amp;cakeshop-def
  image: &quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
  expose:
    - &quot;8999&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy=off&quot;, &quot;http://localhost:8999/actuator/health&quot;]
    interval: 5s
    timeout: 5s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/cakeshop/local
      mkdir -p $${DDIR}
      DOCKER_IMAGE=&quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
      java -Xms128M -Xmx128M -Dcakeshop.config.dir=/qdata/cakeshop -Dlogging.path=/qdata/logs/cakeshop -jar /opt/cakeshop/cakeshop.war
      ;;
services:
  node1:
    &lt;&lt; : *quorum-def
    hostname: node1
    ports:
      - &quot;22000:22000&quot;
      - &quot;21000:21000&quot;
      - &quot;50000:50000&quot;
    volumes:
      - ./data:/qdata
    depends_on:
      - txmanager1
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.11
  txmanager1:
    &lt;&lt; : *tx-manager-def
    hostname: txmanager1
    ports:
      - &quot;9080:9080&quot;
    volumes:
      - ./data:/qdata
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.101
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}

  cakeshop:
    &lt;&lt; : *cakeshop-def
    hostname: cakeshop
    ports:
      - &quot;8999:8999&quot;
    volumes:
      - ./data:/qdata

networks:
  quorum-examples-net:
    name: quorum-examples-net
    driver: bridge
    ipam:
      driver: default
      config:
      - subnet: 172.16.239.0/24
</code></pre>
<h2 id="挂载所需文件及目录">挂载所需文件及目录</h2>
<p>当前目录为 /bsn/quorum</p>
<p>data<br>
|---  cakeshop<br>
|         |-- local<br>
|                 |-- application.properties<br>
|                 |-- nodes.json<br>
|<br>
| --- dd<br>
|       |-- genesis.json<br>
|       |-- keystore<br>
|       |         |-- key<br>
|       |--  passwords.txt<br>
|       |--  permissioned-nodes.json<br>
|       |-- static-nodes.json<br>
|       |-- disallowed-nodes.json<br>
|<br>
|---- tm<br>
|-- tessera-config.json</p>
<h3 id="cakeshop-挂载文件">cakeshop 挂载文件</h3>
<p><strong>application.properties文件为cakeshop的配置文件，配置服务端口，链接文件，安全配置等</strong></p>
<pre><code class="language-yml">#Mon Dec 14 07:18:51 UTC 2020
spring.main.banner-mode=off
security.ignored=/**
geth.log=/logs
spring.mvc.view.suffix=.jsp
geth.auto.stop=false
geth.identity=bradmcdermott
geth.cors.url=
endpoints.actuator.enabled=true
security.basic.enabled=false
nodejs.binary=node
contract.poll.delay.millis=5000
geth.mining=true
cakeshop.initialnodes=qdata/cakeshop/local/nodes.json
geth.node.port=30303
geth.cors.enabled=false
management.security.enabled=false
server.port=8999
geth.release.url=
server.compression.enabled=true
geth.url=http\://localhost\:8102
geth.vote.contract.addr=0x0000000000000000000000000000000000000020
cakeshop.hibernate.jdbc.batch_size=20
cakeshop.database.vendor=hsqldb
geth.consensus.mode=raft
geth.tools.url=
cakeshop.mvc.async.pool.threads.max=1000
cakeshop.jdbc.user=sdk
geth.transaction_manager.url=http\://localhost\:9102
spring.mvc.view.prefix=/WEB-INF/jsp/
geth.verbosity=
geth.auto.start=false
cakeshop.hibernate.hbm2ddl.auto=update
cakeshop.selected_node=1
geth.raft.network.id=
geth.istanbul.url=
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain
geth.bootnode.address=
cakeshop.mvc.async.pool.queue.max=2000
cakeshop.mvc.async.pool.threads.core=250
management.context-path=/manage
geth.db.enabled=true
geth.cred1=admin
geth.datadir=/qdata/cakeshop/local/ethereum
geth.raft.port=22000
geth.cred2=$2a$10$dbGiTnfK/w8MhcpIj3XgROYXRsFMlEYJRWoUYArkr8aSPypUFV25G
geth.params.extra=
geth.raft.blocktime=100
geth.bootnodes.list=
geth.networkid=1006
geth.bootnode.key=
geth.startup.mode=standalone
cakeshop.jdbc.pass=sdk
geth.transaction_manager.peers=http\://localhost\:9102
geth.rpcapi.list=admin,db,eth,debug,miner,net,shh,txpool,personal,web3
log4j.rootLogger=DEBUG, stdout
contract.registry.addr=
geth.unlock.timeout=5000
</code></pre>
<p><strong>nodes.json 文件配置连接quorum服务节点的地址(也可可续在web页面添加)</strong></p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;node1&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.6:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.6:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node2&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.7:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.7:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node3&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.8:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.8:9080&quot;
  }
]
</code></pre>
<h3 id="quorum挂载文件">quorum挂载文件</h3>
<ul>
<li>disallowed-nodes.json：禁止访问定义</li>
<li>keysstore/key：创建用户的账号key存储</li>
<li>genesis.json：创世块文件</li>
<li>passwords.txt：解锁密钥存储</li>
<li>permissioned-nodes.json：允许访问定义列表</li>
<li>static-nodes.json：集群节点连接信息</li>
</ul>
<p><strong>disallowed-nodes.json</strong></p>
<pre><code class="language-bash">[
]
</code></pre>
<p><strong>keysstore/key</strong><br>
账户文件通过命令提前生成<br>
生成的key名字可以更改，密码最好设置为空</p>
<pre><code class="language-bash">geth --datadir dd account new
ll data/dd/keystore/
UTC--2020-12-07T03-33-12.115191344Z--93f0b48f9d921f38dabff36cb682bfb208472221
</code></pre>
<p><strong>genesis.json</strong></p>
<p>文件内的alloc参数根据创建的账户文件生成的key来填写</p>
<pre><code class="language-json">{
  &quot;alloc&quot;: {
    &quot;0xCcfaC6Cfb21D1f10C915d0e4189586765c30089e&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    },
    &quot;0x1ff1a9c504703b8e623640be516e768f3d175d14&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    }
  },
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;config&quot;: {
    &quot;homesteadBlock&quot;: 0,
    &quot;byzantiumBlock&quot;: 0,
    &quot;constantinopleBlock&quot;: 0,
    &quot;petersburgBlock&quot;: 0,
    &quot;istanbulBlock&quot;: 0,
    &quot;chainId&quot;: 10,
    &quot;eip150Block&quot;: 0,
    &quot;eip155Block&quot;: 0,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip158Block&quot;: 0,
    &quot;isQuorum&quot;: true,
    &quot;maxCodeSizeConfig&quot; : [
      {
        &quot;block&quot; : 0,
        &quot;size&quot; : 32
      }
    ]
  },
  &quot;difficulty&quot;: &quot;0x0&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0xE0000000&quot;,
  &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;timestamp&quot;: &quot;0x00&quot;
}
</code></pre>
<p><strong>passwords.txt</strong><br>
最好为空，不然会与在页面创建的用户有冲突</p>
<pre><code class="language-bash">test
</code></pre>
<p><strong>permissioned-nodes.json</strong><br>
文件中的id使用命令提前生成</p>
<pre><code class="language-bash"> bootnode --genkey=nodekey
 cp nodekey 
 bootnode --nodekey=nodekey --writeaddress
</code></pre>
<p>用户的id信息</p>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<p><strong>static-nodes.json</strong></p>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoQuorum之raft共识添加添加隐私交易管理器tessera]]></title>
        <id>https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/</id>
        <link href="https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/">
        </link>
        <updated>2020-12-07T07:37:57.000Z</updated>
        <content type="html"><![CDATA[<p>tessera</p>
<p>公共与私人交易处理<br>
公共交易是以标准的以太坊方式执行的，因此，如果将公共交易发送到持有合同代码的账户，则每个参与者将执行相同的代码，并且其底层StateDB将相应地更新。</p>
<p>但是，私有交易不会按标准的以太坊执行：在发送方的GoQuorum节点将交易传播到网络的其余部分之前，它将原始交易有效载荷替换为从Constellation / Tessera接收到的加密有效载荷的哈希值。参与交易的参与者将能够通过其Constellation / Tessera实例将哈希值替换为实际有效载荷，而未参与交易的参与者将只能看到哈希值。</p>
<p>结果是，如果将私人交易发送到持有合同代码的帐户，则那些不参与交易的参与者将最终跳过交易，因此不执行合同代码。但是，参与交易的那些参与者将在调用EVM执行之前将哈希替换为原始有效负载，并且其StateDB将相应地更新。如果没有对geth客户进行相应的更改，那么这两组参与者最终将拥有不同的StateDB，并且无法达成共识。为了支持合同状态的这种分叉，Quorum将公共合同的状态存储在全局同步的Public State Trie中，</p>
<h2 id="安装goquorum和tessera">安装GoQuorum和tessera</h2>
<pre><code class="language-bash">$ git clone https://github.com/ConsenSys/quorum.git
$ cd quorum
$ make all
$ export PATH=$(pwd)/build/bin:$PATH
$ cd ..
.... copy tessera jar to your desired destination and rename it as tessera
$ mv tessera-app-20.10.0-app.jar tessera.jar
</code></pre>
<h2 id="生成新密钥">生成新密钥</h2>
<pre><code class="language-bash">$ mkdir new-node-1t
$ cd new-node-1t
$ java -jar ../tessera.jar -keygen -filename new-node-1
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:32:51.256 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:32:51.279 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[pnesVeDgs805ZPbnulzC5wokDzpdN7CeYKVUBXup/W4=] and private key REDACTED
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-1t/new-node-1.pub
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-1t/new-node-1.key
</code></pre>
<h2 id="创建configjson配置文件">创建config.json配置文件</h2>
<pre><code class="language-bash">{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-1t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.6:9081&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-1t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.6:9001&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动其他节点">启动其他节点</h2>
<p>如果要启动另一个Tessera节点，请重复步骤2和步骤3</p>
<pre><code class="language-bash">$ cd ..
$ mkdir new-node-2t
$ cd new-node-2t
$ java -jar ../tessera.jar -keygen -filename new-node-2
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:45:02.567 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:45:02.585 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[AeggpVlVsi+rxD6h9tcq/8qL/MsjyipUnkj1nvNPgTU=] and private key REDACTED
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-2t/new-node-2.pub
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-2t/new-node-2.key
$
$ vim config.json

{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-2t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.7:9082&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-2t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.7:9002&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动tessera节点">启动tessera节点</h2>
<p>启动您的Tessera节点，然后发送到后台<br>
分别在192.168.40.6   192.168.40.7执行</p>
<pre><code class="language-bash">java -jar ../tessera.jar -configfile config.json &gt;&gt; tessera.log 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="修改goquorum启动脚本">修改GoQuorum启动脚本</h2>
<p>从上方启动连接到正在运行的Tessera节点的GoQuorum节点并将其发送到后台</p>
<p>192.168.40.6</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-1t/tm.ipc nohup geth --allow-insecure-unlock  --datadir new-node-1 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<p>192.168.40.7</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-2t/tm.ipc nohup geth --allow-insecure-unlock --datadir new-node-2 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<blockquote>
<p>注意：<br>
Tessera IPC桥接器将位于您定义的文件名上config.json，通常以tm.ipc前缀中的名称命名PRIVATE_CONFIG=tm.ipc。您的节点现在可以发送和接收私人交易，播发的公共节点密钥将在new-node-1.pub文件中。Tessera提供了很多配置灵活性，有关完整和最新的配置选项，请参阅Tessera下的“配置”部分。<br>
--allow-insecure-unlock  用于解锁用户</p>
</blockquote>
<h2 id="发送私人交易">发送私人交易</h2>
<p>您的节点现在可以运行了，您可以附加到该节点geth attach new-node-1/geth.ipc以发送私人交易。</p>
<pre><code class="language-bash">$ vim private-contract.js
... create simple private contract to send transaction from new-node-1 private for new-node-2's tessera public key created in step 4
a = eth.accounts[0]
web3.eth.defaultAccount = a;

// abi and bytecode generated from simplestorage.sol:
// &gt; solcjs --bin --abi simplestorage.sol
var abi = [{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;storedData&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;x&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;set&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;get&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;retVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;name&quot;:&quot;initVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;constructor&quot;}];

var bytecode = &quot;0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029&quot;;

var simpleContract = web3.eth.contract(abi);
var simple = simpleContract.new(42, {from:web3.eth.accounts[0], data: bytecode, gas: 0x47b760, privateFor: [&quot;R5qs4JXQ+aiJqh2V98qgbPZj+rR82ZodCq2CAUyIJjw=&quot;]}, function(e, contract) {
    if (e) {
        console.log(&quot;err creating contract&quot;, e);
    } else {
        if (!contract.address) {
            console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;);
        } else {
            console.log(&quot;Contract mined! Address: &quot; + contract.address);
            console.log(contract);
        }
    }
});
$
$
</code></pre>
<blockquote>
<p>注意： 默认情况下，在geth中打开的帐户是锁定的，因此在发送交易之前，请先解锁帐户，所以启动需要加上--allow-insecure-unlock参数，不然解锁用户时会报错Error: account unlock with HTTP access is forbidden</p>
</blockquote>
<pre><code class="language-bash">
[root@test-1 fromscratch]# geth attach new-node-1/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.9.7-stable-7b726385(quorum-v20.10.0)/linux-amd64/go1.15.1
coinbase: 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
at block: 0 (Thu, 01 Jan 1970 08:00:00 CST)
 datadir: /bsn/quorum/fromscratch/new-node-1
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 quorumExtension:1.0 raft:1.0 rpc:1.0 txpool:1.0 web3:1.0

&gt; eth.accounts
[&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;, &quot;0x93f0b48f9d921f38dabff36cb682bfb208472221&quot;]
&gt; personal.unlockAccount(&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;);
Unlock account 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
Password: 
true
&gt; loadScript(&quot;private-contract.js&quot;)
Contract transaction send: TransactionHash: 0xfaf11707339302bc62bfbfe6968ea20e5b511fc1450f799a5ac95a91a512c8fa waiting to be mined...
true
&gt; Contract mined! Address: 0xb85f26e18472df8c33633990b8ba8eb7d012966c
[object Object]

</code></pre>
<p>您已成功将私有事务从节点1发送到节点2！</p>
<blockquote>
<p>注意：如果private-contract.js中的数组中没有有效的公共密钥，则在加载脚本时会看到以下错误。</p>
</blockquote>
<pre><code class="language-bash">&gt; loadScript(&quot;private-contract.js&quot;)
err creating contract Error: Non-200 status code: &amp;{Status:400 Bad Request StatusCode:400 Proto:HTTP/1.1 ProtoMajor:1      ProtoMinor:1 Header:map[Date:[Mon, 17 Jun 2019 15:23:53 GMT] Content-Type:[text/plain] Content-Length:[73] Server:[Jetty(9.4.z-SNAPSHOT)]] Body:0xc01997a580 ContentLength:73 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc019788200 TLS:&lt;nil&gt;}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二进制多机部署GoQuorum之raft共识]]></title>
        <id>https://chriswsq.github.io/post/er-jin-zhi-duo-ji-bu-shu-goquorum-zhi-raft-gong-shi/</id>
        <link href="https://chriswsq.github.io/post/er-jin-zhi-duo-ji-bu-shu-goquorum-zhi-raft-gong-shi/">
        </link>
        <updated>2020-12-07T02:38:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="goquorum与raft达成共识">GoQuorum与Raft达成共识</h2>
<h3 id="测试环境">测试环境</h3>
<ul>
<li>2台主机<br>
192.168.40.6(test-1)           192.168.40.7(test-2)</li>
</ul>
<h3 id="下载安装程序文件">下载安装程序文件</h3>
<pre><code class="language-bash"> git clone https://github.com/ConsenSys/quorum.git
 cd quorum
 make all
 export PATH=$(pwd)/build/bin:$PATH
</code></pre>
<h3 id="创建服务目录">创建服务目录</h3>
<pre><code class="language-bash">mkdir fromscratch
cd fromscratch
mkdir new-node-1
</code></pre>
<h3 id="创建账户">创建账户</h3>
<p>为该节点生成一个或多个帐户并记下帐户地址。根据您要完成的工作，可能需要一个资金帐户</p>
<pre><code class="language-bash">[root@test-1 fromscratch]#  geth --datadir new-node-1 account new
INFO [12-07|11:29:07.567] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|11:29:07.567] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
Your new account is locked with a password. Please give a password. Do not forget this password.
Password: 
Repeat password: 

Your new key was generated

Public address of the key:   0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65
Path of the secret key file: new-node-1/keystore/UTC--2020-12-07T03-30-11.929565315Z--4cccda1f9bc42a72c7a704bdc07f5f384483ff65

- You can share your public address with anyone. Others need it to interact with you.
- You must NEVER share the secret key with anyone! The key controls access to your funds!
- You must BACKUP your key file! Without the key, it's impossible to access account funds!
- You must REMEMBER your password! Without the password, it's impossible to decrypt the key!

[root@test-1 fromscratch]# geth --datadir new-node-1 account new
INFO [12-07|11:33:09.552] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|11:33:09.552] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
Your new account is locked with a password. Please give a password. Do not forget this password.
Password: 
Repeat password: 

Your new key was generated

Public address of the key:   0x93F0B48f9D921f38dabFf36CB682bfB208472221
Path of the secret key file: new-node-1/keystore/UTC--2020-12-07T03-33-12.115191344Z--93f0b48f9d921f38dabff36cb682bfb208472221

- You can share your public address with anyone. Others need it to interact with you.
- You must NEVER share the secret key with anyone! The key controls access to your funds!
- You must BACKUP your key file! Without the key, it's impossible to access account funds!
- You must REMEMBER your password! Without the password, it's impossible to decrypt the key!
</code></pre>
<h3 id="创世块文件">创世块文件</h3>
<p>genesis.json使用此处的示例创建文件。唯一需要进行的更改将是将在上一步中生成的帐户添加到该alloc字段，并为它们预先注资。例如，在这里我们为帐户0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65和0x93F0B48f9D921f38dabFf36CB682bfB208472221提供资金。</p>
<pre><code class="language-bash">vim genesis.json

{
  &quot;alloc&quot;: {
    &quot;0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    },
    &quot;0x93F0B48f9D921f38dabFf36CB682bfB208472221&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    }
  },
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;config&quot;: {
    &quot;homesteadBlock&quot;: 0,
    &quot;byzantiumBlock&quot;: 0,
    &quot;constantinopleBlock&quot;: 0,
    &quot;chainId&quot;: 10,
    &quot;eip150Block&quot;: 0,
    &quot;eip155Block&quot;: 0,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip158Block&quot;: 0,
    &quot;maxCodeSizeConfig&quot;: [
      {
        &quot;block&quot;: 0,
        &quot;size&quot;: 35
      }
    ],
    &quot;isQuorum&quot;: true
  },
  &quot;difficulty&quot;: &quot;0x0&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0xE0000000&quot;,
  &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;timestamp&quot;: &quot;0x00&quot;
}

</code></pre>
<h3 id="生成节点密钥">生成节点密钥</h3>
<p>生成节点密钥并将其复制到datadir</p>
<pre><code class="language-bash"> bootnode --genkey=nodekey
 cp nodekey new-node-1/
</code></pre>
<h3 id="查看节点id">查看节点ID</h3>
<p>执行以下命令以显示新节点的enode ID</p>
<pre><code class="language-bash">bootnode --nodekey=new-node-1/nodekey --writeaddress &gt; new-node-1/enode
cat new-node-1/enode
f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d
</code></pre>
<h3 id="创建static-nodesjson文件">创建static-nodes.json文件</h3>
<p>创建一个名为的文件static-nodes.json并对其进行编辑以匹配此示例。您的文件应在您的节点中包含一行，并带有您的enode的ID以及将用于devp2p和Raft的端口。确保此文件在您的节点数据目录中</p>
<pre><code class="language-bash"> vim static-nodes.json
.... paste below lines with enode generated in previous step, port 21000;IP 127.0.0.1 and raft port set as 50000
[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<h3 id="初始化新节点">初始化新节点</h3>
<p>使用以下命令初始化新节点。</p>
<pre><code class="language-bash">[root@test-1 fromscratch]# geth --datadir new-node-1 init genesis.json
INFO [12-07|13:50:06.610] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|13:50:06.611] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
WARN [12-07|13:50:06.750] permission-config.json file is missing. Smart-contract-based permission service will be disabled error=&quot;stat new-node-1/permission-config.json: no such file or directory&quot;
INFO [12-07|13:50:06.750] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-1/geth/chaindata cache=16.00MiB handles=16
INFO [12-07|13:50:06.808] Writing custom genesis block 
INFO [12-07|13:50:06.829] Persisted trie from memory database      nodes=3 size=417.00B time=247.639µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|13:50:06.850] Successfully wrote genesis state         database=chaindata hash=e1236e…5fecf7
INFO [12-07|13:50:06.850] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-1/geth/lightchaindata cache=16.00MiB handles=16
INFO [12-07|13:50:06.855] Writing custom genesis block 
INFO [12-07|13:50:06.855] Persisted trie from memory database      nodes=3 size=417.00B time=92.049µs  gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|13:50:06.855] Successfully wrote genesis state         database=lightchaindata hash=e1236e…5fecf7
</code></pre>
<h3 id="创建启动脚本">创建启动脚本</h3>
<p>通过首先创建如下脚本然后启动它来启动节点：</p>
<pre><code class="language-bash"> vim startnode1.sh
... paste below commands. It will start it in the background.
#!/bin/bash
PRIVATE_CONFIG=ignore nohup geth --datadir new-node-1 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;

 chmod +x startnode1.sh
 ./startnode1.sh
</code></pre>
<blockquote>
<p>注意：如前缀所示PRIVATE_CONFIG=ignore，此配置将在没有隐私支持的情况下启动GoQuorum ，请参阅以下部分，了解如何通过隐私事务管理器启用隐私。</p>
</blockquote>
<p>您的节点现在可以运行了，您可以使用以下命令将其附加到该节点上。</p>
<pre><code class="language-bash">[root@test-1 fromscratch]# geth attach new-node-1/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.9.7-stable-7b726385(quorum-v20.10.0)/linux-amd64/go1.15.1
coinbase: 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
at block: 0 (Thu, 01 Jan 1970 08:00:00 CST)
 datadir: /bsn/quorum/fromscratch/new-node-1
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 raft:1.0 rpc:1.0 txpool:1.0 web3:1.0

&gt; raft.cluster
[{
    hostname: &quot;192.168.40.6&quot;,
    nodeActive: true,
    nodeId: &quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;,
    p2pPort: 21000,
    raftId: 1,
    raftPort: 50000,
    role: &quot;minter&quot;
}]
&gt; 
&gt; 
&gt; raft.leader
&quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;
&gt; raft.role
&quot;minter&quot;
&gt; exit
</code></pre>
<h2 id="添加其他节点">添加其他节点</h2>
<h3 id="完成上一指南中的步骤1-2-5和6">完成上一指南中的步骤1、2、5和6</h3>
<p>增加192.168.40.7为服务节点</p>
<pre><code class="language-bash">mkdir new-node-2
bootnode --genkey=nodekey2
cp nodekey2 new-node-2/nodekey
bootnode --nodekey=new-node-2/nodekey --writeaddress
3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d
</code></pre>
<h3 id="调整static-nodesjson">调整static-nodes.json</h3>
<pre><code class="language-bash">#在 192.168.40.6 上将static-nodes.json文件传至192.168.40.7
scp  static-nodes.json    root@192.168.40.7:/bsn/quorum/fromscratch/new-node-2

#编辑static-nodes.json并为您正在配置的新节点添加新条目（应该是最后一个）
vim new-node-2/static-nodes.json
[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<h3 id="初始化新节点-2">初始化新节点</h3>
<pre><code class="language-bash">#将192.168.40.6的genesis.json文件拷贝至192.168.40.7
scp  genesis.json    root@192.168.40.7:/bsn/quorum/fromscratch/
[root@test-2 fromscratch]#  geth --datadir new-node-2 init genesis.json
INFO [12-07|14:19:55.539] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|14:19:55.542] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
WARN [12-07|14:19:55.600] permission-config.json file is missing. Smart-contract-based permission service will be disabled error=&quot;stat new-node-2/permission-config.json: no such file or directory&quot;
INFO [12-07|14:19:55.603] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-2/geth/chaindata cache=16.00MiB handles=16
INFO [12-07|14:19:55.649] Writing custom genesis block 
INFO [12-07|14:19:55.693] Persisted trie from memory database      nodes=3 size=417.00B time=200.749µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|14:19:55.694] Successfully wrote genesis state         database=chaindata hash=e1236e…5fecf7
INFO [12-07|14:19:55.694] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-2/geth/lightchaindata cache=16.00MiB handles=16
INFO [12-07|14:19:55.698] Writing custom genesis block 
INFO [12-07|14:19:55.699] Persisted trie from memory database      nodes=3 size=417.00B time=1.166874ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|14:19:55.700] Successfully wrote genesis state         database=lightchaindata hash=e1236e…5fecf7
</code></pre>
<h3 id="连接到链中已运行的节点并执行raftaddpeer命令">连接到链中已运行的节点并执行RaftaddPeer命令。</h3>
<p>在192.168.40.6上执行</p>
<pre><code class="language-bash">&gt; raft.addPeer('enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000')
2
&gt; raft.cluster
[{
    hostname: &quot;192.168.40.7&quot;,
    nodeActive: false,
    nodeId: &quot;3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d&quot;,
    p2pPort: 21000,
    raftId: 2,
    raftPort: 50000,
    role: &quot;verifier&quot;
}, {
    hostname: &quot;192.168.40.6&quot;,
    nodeActive: true,
    nodeId: &quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;,
    p2pPort: 21000,
    raftId: 1,
    raftPort: 50000,
    role: &quot;minter&quot;
}]

</code></pre>
<blockquote>
<p>新加的节点状态为false  因为还为启动节点二</p>
</blockquote>
<h3 id="编辑新增节点脚本">编辑新增节点脚本</h3>
<pre><code class="language-bash">scp startnode1.sh   root@192.168.40.7:/bsn/quorum/fromscratch/

 vim startnode1.sh
..... paste below details
#!/bin/bash
PRIVATE_CONFIG=ignore nohup geth --datadir new-node-2 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50001 --raftjoinexisting 2 --rpc --rpcaddr 0.0.0.0 --rpcport 22001 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21001 2&gt;&gt;node2.log &amp;

 ./startnode1.sh
</code></pre>
<p>此时去192.168.40.6上查看节点状态显示为true</p>
<h3 id="可选static-nodesjson与所有其他连锁店参与者共享新的">可选：static-nodes.json与所有其他连锁店参与者共享新的</h3>
<pre><code class="language-bash">cp new-node-2/static-nodes.json root@192.168.40.6:/bsn/quorum/fromscratch/new-node-1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux 条件判断]]></title>
        <id>https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/</id>
        <link href="https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/">
        </link>
        <updated>2020-12-03T03:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-if-结构">1. if 结构</h2>
<p>if 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<pre><code class="language-bash">if commands; then
  commands
[elif commands; then
  commands...]
[else
  commands]
fi
</code></pre>
<p>这个命令分成三个部分：if、elif和else。其中，后两个部分是可选的。</p>
<p>if 关键字后面是主要的判断条件，elif用来添加在主条件不成立时的其他判断条件，else则是所有条件都不成立时要执行的部分。</p>
<pre><code class="language-bash">if test $USER = &quot;foo&quot;; then
  echo &quot;Hello foo.&quot;
else
  echo &quot;You are not foo.&quot;
fi
</code></pre>
<p>上面的例子中，判断条件是环境变量$USER是否等于foo，如果等于就输出Hello foo.，否则输出其他内容。</p>
<p>if和then写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<pre><code class="language-bash">if true
then
  echo 'hello world'
fi

if false
then
  echo 'it is false' # 本行不会执行
fi
</code></pre>
<p>上面的例子中，true和false是两个特殊命令，前者代表操作成功，后者代表操作失败。if true意味着命令部分总是会执行，if false意味着命令部分永远不会执行。</p>
<p>除了多行的写法，if结构也可以写成单行。</p>
<pre><code class="language-bash">$ if true; then echo 'hello world'; fi
hello world

$ if false; then echo &quot;It's true.&quot;; fi
</code></pre>
<p>注意，if关键字后面也可以是一条命令，该条命令执行成功（返回值0），就意味着判断条件成立。</p>
<pre><code class="language-bash">$ if echo 'hi'; then echo 'hello world'; fi
hi
hello world
</code></pre>
<p>上面命令中，if后面是一条命令echo 'hi'。该命令会执行，如果返回值是0，则执行then的部分。</p>
<p>if后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回0，就会执行then的部分。</p>
<pre><code class="language-bash">$ if false; true; then echo 'hello world'; fi
hello world
</code></pre>
<p>上面例子中，if后面有两条命令（false;true;），第二条命令（true）决定了then的部分是否会执行。</p>
<p>elif部分可以有多个。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
if [ &quot;$character&quot; = &quot;1&quot; ]; then
    echo 1
elif [ &quot;$character&quot; = &quot;2&quot; ]; then
    echo 2
elif [ &quot;$character&quot; = &quot;3&quot; ]; then
    echo 3
else
    echo 输入不符合要求
fi
</code></pre>
<p>上面例子中，如果用户输入3，就会连续判断3次。</p>
<h2 id="2-test-命令">2. test 命令</h2>
<p>if结构的判断条件，一般使用test命令，有三种形式。</p>
<pre><code class="language-bash"># 写法一
test expression

# 写法二
[ expression ]

# 写法三
[[ expression ]]
</code></pre>
<p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的expression是一个表达式。这个表达式为真，test命令执行成功（返回值为0）；表达式为伪，test命令执行失败（返回值为1）。注意，第二种和第三种写法，[和]与内部的表达式之间必须有空格。</p>
<pre><code class="language-bash">$ test -f /etc/hosts
$ echo $?
0

$ [ -f /etc/hosts ]
$  echo $?
0
</code></pre>
<p>上面的例子中，test命令采用两种写法，判断/etc/hosts文件是否存在，这两种写法是等价的。命令执行后，返回值为0，表示该文件确实存在。</p>
<p>实际上，[这个字符是test命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把test命令的三种形式，用在if结构中，判断一个文件是否存在。</p>
<pre><code class="language-bash"># 写法一
if test -e /tmp/foo.txt ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法二
if [ -e /tmp/foo.txt ] ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法三
if [[ -e /tmp/foo.txt ]] ; then
  echo &quot;Found foo.txt&quot;
fi
</code></pre>
<h2 id="3-判断表达式">3. 判断表达式</h2>
<p>if关键字后面，跟的是一个命令。这个命令可以是test命令，也可以是其他命令。命令的返回值为0表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="31-文件判断">3.1 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li>[ -a file ]：如果 file 存在，则为true。</li>
<li>[ -b file ]：如果 file 存在并且是一个块（设备）文件，则为true。</li>
<li>[ -c file ]：如果 file 存在并且是一个字符（设备）文件，则为true。</li>
<li>[ -d file ]：如果 file 存在并且是一个目录，则为true。</li>
<li>[ -e file ]：如果 file 存在，则为true。</li>
<li>[ -f file ]：如果 file 存在并且是一个普通文件，则为true。</li>
<li>[ -g file ]：如果 file 存在并且设置了组 ID，则为true。</li>
<li>[ -G file ]：如果 file 存在并且属于有效的组 ID，则为true。</li>
<li>[ -h file ]：如果 file 存在并且是符号链接，则为true。</li>
<li>[ -k file ]：如果 file 存在并且设置了它的“sticky bit”，则为true。</li>
<li>[ -L file ]：如果 file 存在并且是一个符号链接，则为true。</li>
<li>[ -N file ]：如果 file 存在并且自上次读取后已被修改，则为true。</li>
<li>[ -O file ]：如果 file 存在并且属于有效的用户 ID，则为true。</li>
<li>[ -p file ]：如果 file 存在并且是一个命名管道，则为true。</li>
<li>[ -r file ]：如果 file 存在并且可读（当前用户有可读权限），则为true。</li>
<li>[ -s file ]：如果 file 存在且其长度大于零，则为true。</li>
<li>[ -S file ]：如果 file 存在且是一个网络 socket，则为true。</li>
<li>[ -t fd ]：如果 fd 是一个文件描述符，并且重定向到终端，则为true。 这可以用来判断是否重定向了标准输入／输出错误。</li>
<li>[ -u file ]：如果 file 存在并且设置了 setuid 位，则为true。</li>
<li>[ -w file ]：如果 file 存在并且可写（当前用户拥有可写权限），则为true。</li>
<li>[ -x file ]：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为true。</li>
<li>[ file1 -nt file2 ]：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为true。</li>
<li>[ file1 -ot file2 ]：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为true。</li>
<li>[ FILE1 -ef FILE2 ]：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为true。<br>
下面是一个示例。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

FILE=~/.bashrc

if [ -e &quot;$FILE&quot; ]; then
  if [ -f &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a regular file.&quot;
  fi
  if [ -d &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a directory.&quot;
  fi
  if [ -r &quot;$FILE&quot; ]; then
    echo &quot;$FILE is readable.&quot;
  fi
  if [ -w &quot;$FILE&quot; ]; then
    echo &quot;$FILE is writable.&quot;
  fi
  if [ -x &quot;$FILE&quot; ]; then
    echo &quot;$FILE is executable/searchable.&quot;
  fi
else
  echo &quot;$FILE does not exist&quot;
  exit 1
fi
</code></pre>
<p>上面代码中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>I</mi><mi>L</mi><mi>E</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">放</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">双</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">防</mi><mi mathvariant="normal">止</mi></mrow><annotation encoding="application/x-tex">FILE要放在双引号之中。这样可以防止</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span></span></span></span>FILE为空，因为这时[ -e ]会判断为真。而放在双引号之中，返回的就总是一个空字符串，[ -e &quot;&quot; ]会判断为伪。</p>
<h3 id="32-字符串判断">3.2 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li>[ string ]：如果string不为空（长度大于0），则判断为真。</li>
<li>[ -n string ]：如果字符串string的长度大于零，则判断为真。</li>
<li>[ -z string ]：如果字符串string的长度为零，则判断为真。</li>
<li>[ string1 = string2 ]：如果string1和string2相同，则判断为真。</li>
<li>[ string1 == string2 ] 等同于[ string1 = string2 ]。</li>
<li>[ string1 != string2 ]：如果string1和string2不相同，则判断为真。</li>
<li>[ string1 '&gt;' string2 ]：如果按照字典顺序string1排列在string2之后，则判断为真。</li>
<li>[ string1 '&lt;' string2 ]：如果按照字典顺序string1排列在string2之前，则判断为真。<br>
注意，test命令内部的&gt;和&lt;，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。</li>
</ul>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#!/bin/bash

ANSWER=maybe

if [ -z &quot;$ANSWER&quot; ]; then
  echo &quot;There is no answer.&quot; &gt;&amp;2
  exit 1
fi
if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then
  echo &quot;The answer is YES.&quot;
elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then
  echo &quot;The answer is NO.&quot;
elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then
  echo &quot;The answer is MAYBE.&quot;
else
  echo &quot;The answer is UNKNOWN.&quot;
fi
</code></pre>
<p>上面代码中，首先确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>N</mi><mi>S</mi><mi>W</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">终</mi><mi mathvariant="normal">止</mi><mi mathvariant="normal">脚</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">退</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">为</mi><mn>1</mn><mi mathvariant="normal">。</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi>T</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>i</mi><mi>s</mi><mi>n</mi><mi>o</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">准</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi></mrow><annotation encoding="application/x-tex">ANSWER字符串是否为空。如果为空，就终止脚本，并把退出状态设为1。注意，这里的echo命令把错误信息There is no answer.重定向到标准错误，这是处理错误信息的常用方法。如果</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">终</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">退</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">准</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span></span></span></span>ANSWER字符串不为空，就判断它的值是否等于yes、no或者maybe。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如[ -n &quot;$COUNT&quot; ]，否则变量替换成字符串以后，test命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成[ -n ]，这时会判断为真。如果放在双引号之中，[ -n &quot;&quot; ]就判断为伪。</p>
<h3 id="33-整数判断">3.3 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li>[ integer1 -eq integer2 ]：如果integer1等于integer2，则为true。</li>
<li>[ integer1 -ne integer2 ]：如果integer1不等于integer2，则为true。</li>
<li>[ integer1 -le integer2 ]：如果integer1小于或等于integer2，则为true。</li>
<li>[ integer1 -lt integer2 ]：如果integer1小于integer2，则为true。</li>
<li>[ integer1 -ge integer2 ]：如果integer1大于或等于integer2，则为true。</li>
<li>[ integer1 -gt integer2 ]：如果integer1大于integer2，则为true。<br>
下面是一个用法的例子。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [ -z &quot;$INT&quot; ]; then
  echo &quot;INT is empty.&quot; &gt;&amp;2
  exit 1
fi
if [ $INT -eq 0 ]; then
  echo &quot;INT is zero.&quot;
else
  if [ $INT -lt 0 ]; then
    echo &quot;INT is negative.&quot;
  else
    echo &quot;INT is positive.&quot;
  fi
  if [ $((INT % 2)) -eq 0 ]; then
    echo &quot;INT is even.&quot;
  else
    echo &quot;INT is odd.&quot;
  fi
fi
</code></pre>
<p>上面例子中，先判断变量$INT是否为空，然后判断是否为0，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="34-正则判断">3.4 正则判断</h3>
<p>[[ expression ]]这种判断形式，支持正则表达式。</p>
<pre><code class="language-bash">[[ string1 =~ regex ]]
</code></pre>
<p>上面的语法中，regex是一个正则表示式，=~是正则比较运算符。</p>
<p>下面是一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  echo &quot;INT is an integer.&quot;
  exit 0
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面代码中，先判断变量INT的字符串形式，是否满足^-?[0-9]+$的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="35-test-判断的逻辑运算">3.5 test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个test判断表达式结合起来，创造更复杂的判断。三种逻辑运算AND，OR，和NOT，都有自己的专用符号。</p>
<ul>
<li>AND运算：符号&amp;&amp;，也可使用参数-a。</li>
<li>OR运算：符号||，也可使用参数-o。</li>
<li>NOT运算：符号!。<br>
下面是一个AND的例子，判断整数是否在某个范围之内。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

MIN_VAL=1
MAX_VAL=100

INT=50

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if [[ $INT -ge $MIN_VAL &amp;&amp; $INT -le $MAX_VAL ]]; then
    echo &quot;$INT is within $MIN_VAL to $MAX_VAL.&quot;
  else
    echo &quot;$INT is out of range.&quot;
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面例子中，&amp;&amp;用来连接两个判断条件：大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>I</mi><msub><mi>N</mi><mi>V</mi></msub><mi>A</mi><mi>L</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">MIN_VAL，并且小于等于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span></span></span></span>MAX_VAL。</p>
<p>使用否定操作符!时，最好用圆括号确定转义的范围。</p>
<pre><code class="language-bash">if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then
    echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot;
else
    echo &quot;$INT is in range.&quot;
fi
</code></pre>
<p>上面例子中，test命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="36-算术判断">3.6 算术判断</h3>
<p>Bash 还提供了((...))作为算术条件，进行算术运算的判断。</p>
<pre><code class="language-bash">if ((3 &gt; 2)); then
  echo &quot;true&quot;
fi
</code></pre>
<p>上面代码执行后，会打印出true。</p>
<p>注意，算术判断不需要使用test命令，而是直接使用((...))结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<pre><code class="language-bash">$ if ((1)); then echo &quot;It is true.&quot;; fi
It is true.
$ if ((0)); then echo &quot;It is true.&quot;; else echo &quot;it is false.&quot;; fi
It is false.
</code></pre>
<p>上面例子中，((1))表示判断成立，((0))表示判断不成立。</p>
<p>算术条件((...))也可以用于变量赋值。</p>
<pre><code class="language-bash">$ if (( foo = 5 ));then echo &quot;foo is $foo&quot;; fi
foo is 5
</code></pre>
<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
<pre><code class="language-bash">$ if (( foo = 0 ));then echo &quot;It is true.&quot;;else echo &quot;It is false.&quot;; fi
It is false.
</code></pre>
<p>下面是用算术条件改写的数值判断脚本。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if ((INT == 0)); then
    echo &quot;INT is zero.&quot;
  else
    if ((INT &lt; 0)); then
      echo &quot;INT is negative.&quot;
    else
      echo &quot;INT is positive.&quot;
    fi
    if (( ((INT % 2)) == 0)); then
      echo &quot;INT is even.&quot;
    else
      echo &quot;INT is odd.&quot;
    fi
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>只要是算术表达式，都能用于((...))语法，详见《Bash 的算术运算》一章。</p>
<h3 id="37-普通命令的逻辑运算">3.7 普通命令的逻辑运算</h3>
<p>如果if结构使用的不是test命令，而是普通命令，比如上一节的((...))算术运算，或者test命令与普通命令混用，那么可以使用 Bash 的命令控制操作符&amp;&amp;（AND）和||（OR），进行多个命令的逻辑运算。</p>
<pre><code class="language-bash">$ command1 &amp;&amp; command2
$ command1 || command2
</code></pre>
<p>对于&amp;&amp;操作符，先执行command1，只有command1执行成功后， 才会执行command2。对于||操作符，先执行command1，只有command1执行失败后， 才会执行command2。</p>
<pre><code class="language-bash">$ mkdir temp &amp;&amp; cd temp
</code></pre>
<p>上面的命令会创建一个名为temp的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<pre><code class="language-bash">$ [ -d temp ] || mkdir temp
</code></pre>
<p>上面的命令会测试目录temp是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<pre><code class="language-bash">[ ! -d temp ] &amp;&amp; exit 1
</code></pre>
<p>上面的命令中，如果temp子目录不存在，脚本会终止，并且返回值为1。</p>
<p>下面就是if与&amp;&amp;结合使用的写法。</p>
<pre><code class="language-bash">if [ condition ] &amp;&amp; [ condition ]; then
  command
fi
</code></pre>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#! /bin/bash

filename=$1
word1=$2
word2=$3

if grep $word1 $filename &amp;&amp; grep $word2 $filename
then
  echo &quot;$word1 and $word2 are both in $filename.&quot;
fi
</code></pre>
<p>上面的例子只有在指定文件里面，同时存在搜索词word1和word2，就会执行if的命令部分。</p>
<p>下面的示例演示如何将一个&amp;&amp;判断表达式，改写成对应的if结构。</p>
<pre><code class="language-bash">[[ -d &quot;$dir_name&quot; ]] &amp;&amp; cd &quot;$dir_name&quot; &amp;&amp; rm *

# 等同于

if [[ ! -d &quot;$dir_name&quot; ]]; then
  echo &quot;No such directory: '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! cd &quot;$dir_name&quot;; then
  echo &quot;Cannot cd to '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! rm *; then
  echo &quot;File deletion failed. Check results&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<h2 id="4-case-结构">4. case 结构</h2>
<p>case结构用于多值判断，可以为每个值指定对应的命令，跟包含多个elif的if结构等价，但是语义更好。它的语法如下。</p>
<pre><code class="language-bash">case expression in
  pattern )
    commands ;;
  pattern )
    commands ;;
  ...
esac
</code></pre>
<p>上面代码中，expression是一个表达式，pattern是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（;）结尾。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
case $character in
  1 ) echo 1
    ;;
  2 ) echo 2
    ;;
  3 ) echo 3
    ;;
  * ) echo 输入不符合要求
esac
</code></pre>
<p>上面例子中，最后一条匹配语句的模式是*，这个通配符可以匹配其他字符和没有输入字符的情况，类似if的else部分。</p>
<p>下面是另一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

OS=$(uname -s)

case &quot;$OS&quot; in
  FreeBSD) echo &quot;This is FreeBSD&quot; ;;
  Darwin) echo &quot;This is Mac OSX&quot; ;;
  AIX) echo &quot;This is AIX&quot; ;;
  Minix) echo &quot;This is Minix&quot; ;;
  Linux) echo &quot;This is Linux&quot; ;;
  *) echo &quot;Failed to identify this OS&quot; ;;
esac
</code></pre>
<p>上面的例子判断当前是什么操作系统。</p>
<p>case的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li>a)：匹配a。</li>
<li>a|b)：匹配a或b。</li>
<li>[[:alpha:]])：匹配单个字母。</li>
<li>???)：匹配3个字符的单词。</li>
<li>*.txt)：匹配.txt结尾。</li>
<li>*)：匹配任意输入，通过作为case结构的最后一个模式。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个字母或数字 &gt; &quot;
read character
case $character in
  [[:lower:]] | [[:upper:]] ) echo &quot;输入了字母 $character&quot;
                              ;;
  [0-9] )                     echo &quot;输入了数字 $character&quot;
                              ;;
  * )                         echo &quot;输入不符合要求&quot;
esac
</code></pre>
<p>上面例子中，使用通配符[[:lower:]] | [[:upper:]]匹配字母，[0-9]匹配数字。</p>
<p>Bash 4.0之前，case结构只能匹配一个条件，然后就会退出case结构。Bash 4.0之后，允许匹配多个条件，这时可以用;;&amp;终止每个条件块。</p>
<pre><code class="language-bash">#!/bin/bash
# test.sh

read -n 1 -p &quot;Type a character &gt; &quot;
echo
case $REPLY in
  [[:upper:]])    echo &quot;'$REPLY' is upper case.&quot; ;;&amp;
  [[:lower:]])    echo &quot;'$REPLY' is lower case.&quot; ;;&amp;
  [[:alpha:]])    echo &quot;'$REPLY' is alphabetic.&quot; ;;&amp;
  [[:digit:]])    echo &quot;'$REPLY' is a digit.&quot; ;;&amp;
  [[:graph:]])    echo &quot;'$REPLY' is a visible character.&quot; ;;&amp;
  [[:punct:]])    echo &quot;'$REPLY' is a punctuation symbol.&quot; ;;&amp;
  [[:space:]])    echo &quot;'$REPLY' is a whitespace character.&quot; ;;&amp;
  [[:xdigit:]])   echo &quot;'$REPLY' is a hexadecimal digit.&quot; ;;&amp;
esac
</code></pre>
<p>执行上面的脚本，会得到下面的结果。</p>
<pre><code class="language-bash">$ test.sh
Type a character &gt; a
'a' is lower case.
'a' is alphabetic.
'a' is a visible character.
'a' is a hexadecimal digit.
</code></pre>
<p>可以看到条件语句结尾添加了;;&amp;以后，在匹配一个条件之后，并没有退出case结构，而是继续判断下一个条件。</p>
<h2 id="5-参考链接">5. 参考链接</h2>
<p><a href="https://wangdoc.com/bash/condition.html">转载自</a><br>
<a href="http://linuxcommand.org/tlcl.php">The Linux Command Line</a>, William Shotts</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[neo服务更新]]></title>
        <id>https://chriswsq.github.io/post/neo-fu-wu-geng-xin/</id>
        <link href="https://chriswsq.github.io/post/neo-fu-wu-geng-xin/">
        </link>
        <updated>2020-11-23T06:03:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="neo服务更新">neo服务更新</h1>
<h2 id="清理旧数据">清理旧数据</h2>
<pre><code class="language-bash">docker rm -f    neo-cli

docker rmi neongd/neo-cli

find  /bsn/neo/ -type d | xargs rm -rf {} \;
</code></pre>
<h2 id="安装新版本neo">安装新版本neo</h2>
<pre><code class="language-bash">docker pull neongd/neo-cli

docker run --name=neo-cli -dit -p 10332-10334:10332-10334  -v /bsn/neo/chain.acc.zip:/neo-cli/chain.acc.zip -v /bsn/neo/ApplicationLogs_00746E41:/neo-cli/ApplicationLogs_00746E41 -v /bsn/neo/Chain_00746E41:/neo-cli/Chain_00746E41 -v /bsn/neo/Index_00746E41:/neo-cli/Index_00746E41 -v /bsn/neo/Nep5BalanceData:/neo-cli/Nep5BalanceData -v /bsn/neo/SystemAssetBalanceData:/neo-cli/SystemAssetBalanceData --restart=always neongd/neo-cli


docker exec -it neo-cli bash

screen -r node

install SimplePolicy
install RpcSecurity
install ApplicationLogs
install ImportBlocks
install RpcWallet
install RpcNep5Tracker
install RpcSystemAsseTtracker
install CoreMetrics
install StatesDumper


docker container restart neo-cli
</code></pre>
<h2 id="查看状态">查看状态</h2>
<p>两个值在变动则为正常</p>
<pre><code class="language-bash">docker exec -it neo-cli  bash

screen -r node 

show state
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[公链之oasis]]></title>
        <id>https://chriswsq.github.io/post/gong-lian-zhi-oasis/</id>
        <link href="https://chriswsq.github.io/post/gong-lian-zhi-oasis/">
        </link>
        <updated>2020-11-03T08:58:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="非验证节点">非验证节点</h2>
<p>填写绿洲P2P地址，同步公链数据</p>
<p>（普通节点）</p>
<h2 id="验证节点">验证节点</h2>
<p>需要创建实体，控制网络上的个人或组织的奖金</p>
<p>需要下载oasis app ，生成账户的公私钥</p>
<p>（共识节点）</p>
<h2 id="paratime节点">ParaTime节点</h2>
<p>目前还是测试版本</p>
<ol>
<li>
<p>要运行ParaTime节点，您必须已经是具有在网络上注册的实体ID的Oasis验证器。您可能已经在运行：</p>
<ul>
<li>
<p>一个或多个验证器节点</p>
<p>也就是需要至少有一个共识节点</p>
</li>
<li>
<p>可选的非验证者节点</p>
</li>
</ul>
</li>
</ol>
<h2 id="非验证节点-2">非验证节点</h2>
<p>根据实际需求我们需要使用非验证节点，但非验证节点启动时没有rpc端口，所以要借助网关来代理出去端<br>
口，</p>
<p>参考<br>
https://docs.oasis.dev/general/run-a-node/set-up-your-node/run-non-validator<br>
https://docs.oasis.dev/oasis-core/high-level-components/oasis-node/rpc<br>
https://docs.oasis.dev/general/oasis-network/network-parameters<br>
https://github.com/oasisprotocol/oasis-core/releases/tag/v20.10<br>
https://github.com/oasisprotocol/oasis-core-rosetta-gateway</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis]]></title>
        <id>https://chriswsq.github.io/post/redis/</id>
        <link href="https://chriswsq.github.io/post/redis/">
        </link>
        <updated>2020-10-31T09:29:16.000Z</updated>
        <content type="html"><![CDATA[<p>https://segmentfault.com/a/1190000022808576</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cita链管理服务部署]]></title>
        <id>https://chriswsq.github.io/post/cita-lian-guan-li-fu-wu-bu-shu/</id>
        <link href="https://chriswsq.github.io/post/cita-lian-guan-li-fu-wu-bu-shu/">
        </link>
        <updated>2020-10-29T08:32:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1链管理服务依赖环境">1.链管理服务依赖环境</h2>
<p>•	python &gt;= 3.7.9<br>
•	docker &gt;= 19.0</p>
<ol>
<li>安装3.7.9版本参考：<br>
https://blog.csdn.net/lkgCSDN/article/details/84403329<br>
https://chriswsq.github.io/post/elk-gao-jing-zhi-elastalert-bu-shu-ji-pei-zhi/</li>
</ol>
<p>ln -s  /usr/local/python3/bin/pip3  /usr/bin/pip3<br>
ln -s  /usr/local/python3  /usr/bin/python3<br>
ln -s /usr/local/python3/bin/gunicorn /usr/bin/gunicorn</p>
<h2 id="2链管理服务部署步骤">2.链管理服务部署步骤</h2>
<ul>
<li>解压源码包并进入目录</li>
</ul>
<pre><code class="language-bash">tar xzvf bsn-cita-chain-manager.tar.gz
cd bsn-cita-chain-manager
</code></pre>
<ul>
<li>
<p>安装依赖包<br>
<code>pip3 install -r requirements.txt -i https://pypi.douban.com/simple</code></p>
</li>
<li>
<p>生成pub_key、pri_key</p>
</li>
</ul>
<p>通过cita-cli工具，执行 ./cita-cli key create --algorithm sm2，将 address 字段写入pub_key，将 private 字段写入pri_key</p>
<ul>
<li>修改配置文件</li>
</ul>
<pre><code class="language-bash">vim conf/config.py

# 链节点密钥对的路径及文件名称
PUBKEY_PATH = '/opt/pub_key'
PRIKEY_PATH = '/opt/pri_key'

# cita 镜像名称，rebirth 镜像名称以及 rebirth 依赖 mysql 的镜像名称（下文详细说明）
CITA_IMAGE_VERSION = 'cita/cita-ee:1.3.1-sm2-sm3'
MYSQL_IMAGE_VERSION = 'cita-for-bsn-mysql:5.7'
REBIRTH_IMAGE_VERSION = 'cita-for-bsn-rebirth:0.1'

# 链管理服务产生链配置的目录
CHAIN_CONFIG_PATH = '/opt/all-chain-config'

# 链节点 TLS 证书所在目录
TLS_PATH = '/opt'

# solc 编译器镜像名称
SOLC_IMAGE_VERSION = 'ethereum/solc:0.4.24'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker-compsoe部署kafka集群]]></title>
        <id>https://chriswsq.github.io/post/docker-compsoe-bu-shu-kafka-ji-qun/</id>
        <link href="https://chriswsq.github.io/post/docker-compsoe-bu-shu-kafka-ji-qun/">
        </link>
        <updated>2020-10-16T10:00:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>kafka依赖于zookeeper存放元数据, 所以在创建kafka集群之前需要创建zookeeper; 更多关于zookeeper集群创建见: 使用Docker部署zookeeper集群</p>
<h2 id="拉取镜像">拉取镜像</h2>
<pre><code class="language-bash">docker pull zookeeper:3.4
docker pull zookeeper:3.4 docker pull wurstmeister/kafka_2.13-2.6.0
</code></pre>
<blockquote>
<p>其中kafka版本中的2.12为Scala版本</p>
</blockquote>
<h2 id="创建子网段">创建子网段</h2>
<pre><code class="language-bash">docker network create --subnet 172.30.1.0/16 --gateway 172.30.0.1 kafka
</code></pre>
<pre><code class="language-yaml">version: '3'

services: 
    zoo1:
        image: zookeeper:3.4
        restart: always
        hostname: zoo1
        container_name: zoo1
        ports:
            - 2184:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo1/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo1/datalog:/datalog
        environment: 
            ZOO_MY_ID: 1
            ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.11

    zoo2:
        image: zookeeper:3.4
        restart: always
        hostname: zoo2
        container_name: zoo2
        ports:
            - 2185:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo2/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo2/datalog:/datalog
        environment: 
            ZOO_MY_ID: 2
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zoo3:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.12

    zoo3:
        image: zookeeper:3.4
        restart: always
        hostname: zoo3
        container_name: zoo3
        ports:
            - 2186:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo3/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo3/datalog:/datalog
        environment: 
            ZOO_MY_ID: 3
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=0.0.0.0:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.13

    kafka1:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka1
        container_name: kafka1
        privileged: true
        ports:
            - 9092:9092
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka1
              KAFKA_LISTENERS: PLAINTEXT://kafka1:9092
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:9092
              KAFKA_ADVERTISED_PORT: 9092
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka1/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.11
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13
        depends_on: 
            - zoo1
            - zoo2
            - zoo3
        external_links: 
            - zoo1
            - zoo2
            - zoo3

    kafka2:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka2
        container_name: kafka2
        privileged: true
        ports:
            - 9093:9093
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka2
              KAFKA_LISTENERS: PLAINTEXT://kafka2:9093
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka2:9093
              KAFKA_ADVERTISED_PORT: 9093
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka2/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.12
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13                
        depends_on: 
            - zoo1
            - zoo2
            - zoo3                
        external_links: 
            - zoo1
            - zoo2
            - zoo3           

    kafka3:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka3
        container_name: kafka3
        privileged: true
        ports:
            - 9094:9094
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka3
              KAFKA_LISTENERS: PLAINTEXT://kafka3:9094
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka3:9094
              KAFKA_ADVERTISED_PORT: 9094
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka3/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.13
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13                
        depends_on: 
            - zoo1
            - zoo2
            - zoo3                
        external_links: 
            - zoo1
            - zoo2
            - zoo3

networks: 
  kafka:
     ipam:
       config:
         - subnet: 172.30.0.0/16
</code></pre>
<blockquote>
<p>在kafka服务中声明了depends_on, 所以在所有zookeeper启动之后才会真正启动kafka容器</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loki配置邮件告警]]></title>
        <id>https://chriswsq.github.io/post/loki-pei-zhi-you-jian-gao-jing/</id>
        <link href="https://chriswsq.github.io/post/loki-pei-zhi-you-jian-gao-jing/">
        </link>
        <updated>2020-10-12T09:43:07.000Z</updated>
        <summary type="html"><![CDATA[<p>监控的目的就是及时发现问题去解决处理，那么在告警就是必不可少的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>监控的目的就是及时发现问题去解决处理，那么在告警就是必不可少的。</p>
<!-- more -->
<p>本次告警配置是loki结合grafana来进行邮件告警</p>
<h2 id="grafana配置告警">grafana配置告警</h2>
<p>1.通过标签定位到需要查看的服务,并通过关键字过滤出想要查看的日志内容<br>
<img src="https://chriswsq.github.io/post-images/1602669342426.png" alt="" loading="lazy"></p>
<p>为尽快得到告警邮件这里我们设置带有info字符的日志</p>
<p>2.看下过去一段时间内，日志中带有info字段的趋势<br>
<img src="https://chriswsq.github.io/post-images/1602496164171.png" alt="" loading="lazy"></p>
<p>这里可以看到，日志在不停的打印带有info字段的日志</p>
<p>在数据源中添加一个Prometheus类型，并在地址栏中填写上http://loki:3100/loki ,这样我们就能通过像查询prometheus一样查询日志的走势<br>
<img src="https://chriswsq.github.io/post-images/1602496373242.png" alt="" loading="lazy"></p>
<p>这时候再创建一个pannel来查询info日志的趋势就可以得到如下结果：</p>
<figure data-type="image" tabindex="1"><img src="https://chriswsq.github.io/post-images/1602496436562.png" alt="" loading="lazy"></figure>
<p>接下来的工作，就是在Grafana上添加一个Alert小铃铛，让它每分钟去Loki里面查询有没有出现info字段的日志出现，如果计算出来的结果大于0，就让Grafana通过邮件告警出来。</p>
<figure data-type="image" tabindex="2"><img src="https://chriswsq.github.io/post-images/1602496637970.png" alt="" loading="lazy"></figure>
<p>配置完成后不急保存，我们先Test rule看看rule是否能生效。</p>
<p><img src="https://chriswsq.github.io/post-images/1602496687577.png" alt="" loading="lazy"><br>
看到state:&quot;alerting&quot; 说明现在已经开始报警了</p>
<h2 id="grafana配置邮件">grafana配置邮件</h2>
<pre><code class="language-ini">[smtp]
enabled = true
host = smtp.163.com:25
user = 你的邮箱
# If the password contains # or ; you have to wrap it with triple quotes. Ex &quot;&quot;&quot;#password;&quot;&quot;&quot;
password = 你的密码
;cert_file =
;key_file =
;skip_verify = false
from_address = 你的邮箱
from_name = Grafana
</code></pre>
<p>修改后，保存退出，重启grafana服务</p>
<ul>
<li>登入grafana页面</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://chriswsq.github.io/post-images/1602496941499.png" alt="" loading="lazy"></figure>
<ul>
<li>创建邮件发送规则</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://chriswsq.github.io/post-images/1602497009120.png" alt="" loading="lazy"></figure>
<p>可以为不同的业务组创建不同的通知通道，例如，运维通道为Ops，研发为Dev。然后可以为一个Metrics指定多个通知通道。</p>
<p>Name为通道名称</p>
<p>Type为通道类型，此处选Email，也可选择钉钉告警或者Alert Manager等告警类型。</p>
<p>Default(send on all alerts)开启后，表示在所有Graph Panel中配置告警规则时默认都会选用此通道。该选项默认为关闭。</p>
<p>Include image开启后，表示是发送告警图片。</p>
<p>Disable Resove Message开启后，表示发送恢复邮件，默认关闭。</p>
<p>Send reminders开启后，还需设置下方的发送间隔，表示发送告警邮件的间隔，默认关闭表示若某个告警发生后即使持续很长时间也仅发送一次邮件。</p>
<p>多个邮箱地址间用分号&quot;;&quot;隔开。例：xxx@163.com;xxx@qq.com</p>
<p>创建成功后，点击Send Test 按钮，测试邮件是否能发送成功。（如果发送不成功，可在grafana.log中查看日志信息）</p>
<ul>
<li>在告警中添加配置的告警邮件联系人组</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chriswsq.github.io/post-images/1602497296964.png" alt="" loading="lazy"></figure>
<ul>
<li>收到告警邮件</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://chriswsq.github.io/post-images/1602497366975.png" alt="" loading="lazy"></figure>
<p>也可以发送图片 ,根据提示安装插件即可<br>
<img src="https://chriswsq.github.io/post-images/1602497453813.png" alt="" loading="lazy"></p>
<p>安装图片插件 官方建议单独新建一个容器去取加载插件而非直接在grafana容器中安装插件</p>
<pre><code class="language-yaml">version: '2'

services:
  grafana:
    image: grafana/grafana:7.0.0-beta1
    ports:
      - 3000
    environment:
      GF_RENDERING_SERVER_URL: http://renderer:8081/render
      GF_RENDERING_CALLBACK_URL: http://grafana:3000/
      GF_LOG_FILTERS: rendering:debug
  renderer:
    image: grafana/grafana-image-renderer:2.0.0-beta1
    ports:
      - 8081
    environment:
      ENABLE_METRICS: 'true'
</code></pre>
<p>结果为<br>
<img src="https://chriswsq.github.io/post-images/1602668961665.png" alt="" loading="lazy"></p>
<p>参考文档：<br>
https://grafana.com/blog/2020/05/07/grafana-7.0-preview-new-image-renderer-plugin-to-replace-phantomjs/<br>
https://www.jianshu.com/p/0982a8ee204c</p>
]]></content>
    </entry>
</feed>