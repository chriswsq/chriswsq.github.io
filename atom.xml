<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriswsq.github.io</id>
    <title>chris&apos;wang</title>
    <updated>2020-12-03T05:40:31.899Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriswsq.github.io"/>
    <link rel="self" href="https://chriswsq.github.io/atom.xml"/>
    <subtitle>当你觉得无所事事时，那你就是在虚度光阴</subtitle>
    <logo>https://chriswsq.github.io/images/avatar.png</logo>
    <icon>https://chriswsq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, chris&apos;wang</rights>
    <entry>
        <title type="html"><![CDATA[linux 条件判断]]></title>
        <id>https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/</id>
        <link href="https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/">
        </link>
        <updated>2020-12-03T03:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-if-结构">1. if 结构</h2>
<p>if 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<pre><code class="language-bash">if commands; then
  commands
[elif commands; then
  commands...]
[else
  commands]
fi
</code></pre>
<p>这个命令分成三个部分：if、elif和else。其中，后两个部分是可选的。</p>
<p>if 关键字后面是主要的判断条件，elif用来添加在主条件不成立时的其他判断条件，else则是所有条件都不成立时要执行的部分。</p>
<pre><code class="language-bash">if test $USER = &quot;foo&quot;; then
  echo &quot;Hello foo.&quot;
else
  echo &quot;You are not foo.&quot;
fi
</code></pre>
<p>上面的例子中，判断条件是环境变量$USER是否等于foo，如果等于就输出Hello foo.，否则输出其他内容。</p>
<p>if和then写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<pre><code class="language-bash">if true
then
  echo 'hello world'
fi

if false
then
  echo 'it is false' # 本行不会执行
fi
</code></pre>
<p>上面的例子中，true和false是两个特殊命令，前者代表操作成功，后者代表操作失败。if true意味着命令部分总是会执行，if false意味着命令部分永远不会执行。</p>
<p>除了多行的写法，if结构也可以写成单行。</p>
<pre><code class="language-bash">$ if true; then echo 'hello world'; fi
hello world

$ if false; then echo &quot;It's true.&quot;; fi
</code></pre>
<p>注意，if关键字后面也可以是一条命令，该条命令执行成功（返回值0），就意味着判断条件成立。</p>
<pre><code class="language-bash">$ if echo 'hi'; then echo 'hello world'; fi
hi
hello world
</code></pre>
<p>上面命令中，if后面是一条命令echo 'hi'。该命令会执行，如果返回值是0，则执行then的部分。</p>
<p>if后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回0，就会执行then的部分。</p>
<pre><code class="language-bash">$ if false; true; then echo 'hello world'; fi
hello world
</code></pre>
<p>上面例子中，if后面有两条命令（false;true;），第二条命令（true）决定了then的部分是否会执行。</p>
<p>elif部分可以有多个。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
if [ &quot;$character&quot; = &quot;1&quot; ]; then
    echo 1
elif [ &quot;$character&quot; = &quot;2&quot; ]; then
    echo 2
elif [ &quot;$character&quot; = &quot;3&quot; ]; then
    echo 3
else
    echo 输入不符合要求
fi
</code></pre>
<p>上面例子中，如果用户输入3，就会连续判断3次。</p>
<h2 id="2-test-命令">2. test 命令</h2>
<p>if结构的判断条件，一般使用test命令，有三种形式。</p>
<pre><code class="language-bash"># 写法一
test expression

# 写法二
[ expression ]

# 写法三
[[ expression ]]
</code></pre>
<p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的expression是一个表达式。这个表达式为真，test命令执行成功（返回值为0）；表达式为伪，test命令执行失败（返回值为1）。注意，第二种和第三种写法，[和]与内部的表达式之间必须有空格。</p>
<pre><code class="language-bash">$ test -f /etc/hosts
$ echo $?
0

$ [ -f /etc/hosts ]
$  echo $?
0
</code></pre>
<p>上面的例子中，test命令采用两种写法，判断/etc/hosts文件是否存在，这两种写法是等价的。命令执行后，返回值为0，表示该文件确实存在。</p>
<p>实际上，[这个字符是test命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把test命令的三种形式，用在if结构中，判断一个文件是否存在。</p>
<pre><code class="language-bash"># 写法一
if test -e /tmp/foo.txt ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法二
if [ -e /tmp/foo.txt ] ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法三
if [[ -e /tmp/foo.txt ]] ; then
  echo &quot;Found foo.txt&quot;
fi
</code></pre>
<h2 id="3-判断表达式">3. 判断表达式</h2>
<p>if关键字后面，跟的是一个命令。这个命令可以是test命令，也可以是其他命令。命令的返回值为0表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="31-文件判断">3.1 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li>[ -a file ]：如果 file 存在，则为true。</li>
<li>[ -b file ]：如果 file 存在并且是一个块（设备）文件，则为true。</li>
<li>[ -c file ]：如果 file 存在并且是一个字符（设备）文件，则为true。</li>
<li>[ -d file ]：如果 file 存在并且是一个目录，则为true。</li>
<li>[ -e file ]：如果 file 存在，则为true。</li>
<li>[ -f file ]：如果 file 存在并且是一个普通文件，则为true。</li>
<li>[ -g file ]：如果 file 存在并且设置了组 ID，则为true。</li>
<li>[ -G file ]：如果 file 存在并且属于有效的组 ID，则为true。</li>
<li>[ -h file ]：如果 file 存在并且是符号链接，则为true。</li>
<li>[ -k file ]：如果 file 存在并且设置了它的“sticky bit”，则为true。</li>
<li>[ -L file ]：如果 file 存在并且是一个符号链接，则为true。</li>
<li>[ -N file ]：如果 file 存在并且自上次读取后已被修改，则为true。</li>
<li>[ -O file ]：如果 file 存在并且属于有效的用户 ID，则为true。</li>
<li>[ -p file ]：如果 file 存在并且是一个命名管道，则为true。</li>
<li>[ -r file ]：如果 file 存在并且可读（当前用户有可读权限），则为true。</li>
<li>[ -s file ]：如果 file 存在且其长度大于零，则为true。</li>
<li>[ -S file ]：如果 file 存在且是一个网络 socket，则为true。</li>
<li>[ -t fd ]：如果 fd 是一个文件描述符，并且重定向到终端，则为true。 这可以用来判断是否重定向了标准输入／输出错误。</li>
<li>[ -u file ]：如果 file 存在并且设置了 setuid 位，则为true。</li>
<li>[ -w file ]：如果 file 存在并且可写（当前用户拥有可写权限），则为true。</li>
<li>[ -x file ]：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为true。</li>
<li>[ file1 -nt file2 ]：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为true。</li>
<li>[ file1 -ot file2 ]：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为true。</li>
<li>[ FILE1 -ef FILE2 ]：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为true。<br>
下面是一个示例。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

FILE=~/.bashrc

if [ -e &quot;$FILE&quot; ]; then
  if [ -f &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a regular file.&quot;
  fi
  if [ -d &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a directory.&quot;
  fi
  if [ -r &quot;$FILE&quot; ]; then
    echo &quot;$FILE is readable.&quot;
  fi
  if [ -w &quot;$FILE&quot; ]; then
    echo &quot;$FILE is writable.&quot;
  fi
  if [ -x &quot;$FILE&quot; ]; then
    echo &quot;$FILE is executable/searchable.&quot;
  fi
else
  echo &quot;$FILE does not exist&quot;
  exit 1
fi
</code></pre>
<p>上面代码中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>I</mi><mi>L</mi><mi>E</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">放</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">双</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">防</mi><mi mathvariant="normal">止</mi></mrow><annotation encoding="application/x-tex">FILE要放在双引号之中。这样可以防止</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span></span></span></span>FILE为空，因为这时[ -e ]会判断为真。而放在双引号之中，返回的就总是一个空字符串，[ -e &quot;&quot; ]会判断为伪。</p>
<h3 id="32-字符串判断">3.2 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li>[ string ]：如果string不为空（长度大于0），则判断为真。</li>
<li>[ -n string ]：如果字符串string的长度大于零，则判断为真。</li>
<li>[ -z string ]：如果字符串string的长度为零，则判断为真。</li>
<li>[ string1 = string2 ]：如果string1和string2相同，则判断为真。</li>
<li>[ string1 == string2 ] 等同于[ string1 = string2 ]。</li>
<li>[ string1 != string2 ]：如果string1和string2不相同，则判断为真。</li>
<li>[ string1 '&gt;' string2 ]：如果按照字典顺序string1排列在string2之后，则判断为真。</li>
<li>[ string1 '&lt;' string2 ]：如果按照字典顺序string1排列在string2之前，则判断为真。<br>
注意，test命令内部的&gt;和&lt;，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。</li>
</ul>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#!/bin/bash

ANSWER=maybe

if [ -z &quot;$ANSWER&quot; ]; then
  echo &quot;There is no answer.&quot; &gt;&amp;2
  exit 1
fi
if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then
  echo &quot;The answer is YES.&quot;
elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then
  echo &quot;The answer is NO.&quot;
elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then
  echo &quot;The answer is MAYBE.&quot;
else
  echo &quot;The answer is UNKNOWN.&quot;
fi
</code></pre>
<p>上面代码中，首先确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>N</mi><mi>S</mi><mi>W</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">终</mi><mi mathvariant="normal">止</mi><mi mathvariant="normal">脚</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">退</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">为</mi><mn>1</mn><mi mathvariant="normal">。</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi>T</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>i</mi><mi>s</mi><mi>n</mi><mi>o</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">准</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi></mrow><annotation encoding="application/x-tex">ANSWER字符串是否为空。如果为空，就终止脚本，并把退出状态设为1。注意，这里的echo命令把错误信息There is no answer.重定向到标准错误，这是处理错误信息的常用方法。如果</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">终</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">退</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">准</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span></span></span></span>ANSWER字符串不为空，就判断它的值是否等于yes、no或者maybe。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如[ -n &quot;$COUNT&quot; ]，否则变量替换成字符串以后，test命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成[ -n ]，这时会判断为真。如果放在双引号之中，[ -n &quot;&quot; ]就判断为伪。</p>
<h3 id="33-整数判断">3.3 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li>[ integer1 -eq integer2 ]：如果integer1等于integer2，则为true。</li>
<li>[ integer1 -ne integer2 ]：如果integer1不等于integer2，则为true。</li>
<li>[ integer1 -le integer2 ]：如果integer1小于或等于integer2，则为true。</li>
<li>[ integer1 -lt integer2 ]：如果integer1小于integer2，则为true。</li>
<li>[ integer1 -ge integer2 ]：如果integer1大于或等于integer2，则为true。</li>
<li>[ integer1 -gt integer2 ]：如果integer1大于integer2，则为true。<br>
下面是一个用法的例子。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [ -z &quot;$INT&quot; ]; then
  echo &quot;INT is empty.&quot; &gt;&amp;2
  exit 1
fi
if [ $INT -eq 0 ]; then
  echo &quot;INT is zero.&quot;
else
  if [ $INT -lt 0 ]; then
    echo &quot;INT is negative.&quot;
  else
    echo &quot;INT is positive.&quot;
  fi
  if [ $((INT % 2)) -eq 0 ]; then
    echo &quot;INT is even.&quot;
  else
    echo &quot;INT is odd.&quot;
  fi
fi
</code></pre>
<p>上面例子中，先判断变量$INT是否为空，然后判断是否为0，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="34-正则判断">3.4 正则判断</h3>
<p>[[ expression ]]这种判断形式，支持正则表达式。</p>
<pre><code class="language-bash">[[ string1 =~ regex ]]
</code></pre>
<p>上面的语法中，regex是一个正则表示式，=~是正则比较运算符。</p>
<p>下面是一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  echo &quot;INT is an integer.&quot;
  exit 0
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面代码中，先判断变量INT的字符串形式，是否满足^-?[0-9]+$的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="35-test-判断的逻辑运算">3.5 test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个test判断表达式结合起来，创造更复杂的判断。三种逻辑运算AND，OR，和NOT，都有自己的专用符号。</p>
<ul>
<li>AND运算：符号&amp;&amp;，也可使用参数-a。</li>
<li>OR运算：符号||，也可使用参数-o。</li>
<li>NOT运算：符号!。<br>
下面是一个AND的例子，判断整数是否在某个范围之内。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

MIN_VAL=1
MAX_VAL=100

INT=50

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if [[ $INT -ge $MIN_VAL &amp;&amp; $INT -le $MAX_VAL ]]; then
    echo &quot;$INT is within $MIN_VAL to $MAX_VAL.&quot;
  else
    echo &quot;$INT is out of range.&quot;
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面例子中，&amp;&amp;用来连接两个判断条件：大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>I</mi><msub><mi>N</mi><mi>V</mi></msub><mi>A</mi><mi>L</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">MIN_VAL，并且小于等于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span></span></span></span>MAX_VAL。</p>
<p>使用否定操作符!时，最好用圆括号确定转义的范围。</p>
<pre><code class="language-bash">if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then
    echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot;
else
    echo &quot;$INT is in range.&quot;
fi
</code></pre>
<p>上面例子中，test命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="36-算术判断">3.6 算术判断</h3>
<p>Bash 还提供了((...))作为算术条件，进行算术运算的判断。</p>
<pre><code class="language-bash">if ((3 &gt; 2)); then
  echo &quot;true&quot;
fi
</code></pre>
<p>上面代码执行后，会打印出true。</p>
<p>注意，算术判断不需要使用test命令，而是直接使用((...))结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<pre><code class="language-bash">$ if ((1)); then echo &quot;It is true.&quot;; fi
It is true.
$ if ((0)); then echo &quot;It is true.&quot;; else echo &quot;it is false.&quot;; fi
It is false.
</code></pre>
<p>上面例子中，((1))表示判断成立，((0))表示判断不成立。</p>
<p>算术条件((...))也可以用于变量赋值。</p>
<pre><code class="language-bash">$ if (( foo = 5 ));then echo &quot;foo is $foo&quot;; fi
foo is 5
</code></pre>
<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
<pre><code class="language-bash">$ if (( foo = 0 ));then echo &quot;It is true.&quot;;else echo &quot;It is false.&quot;; fi
It is false.
</code></pre>
<p>下面是用算术条件改写的数值判断脚本。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if ((INT == 0)); then
    echo &quot;INT is zero.&quot;
  else
    if ((INT &lt; 0)); then
      echo &quot;INT is negative.&quot;
    else
      echo &quot;INT is positive.&quot;
    fi
    if (( ((INT % 2)) == 0)); then
      echo &quot;INT is even.&quot;
    else
      echo &quot;INT is odd.&quot;
    fi
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>只要是算术表达式，都能用于((...))语法，详见《Bash 的算术运算》一章。</p>
<h3 id="37-普通命令的逻辑运算">3.7 普通命令的逻辑运算</h3>
<p>如果if结构使用的不是test命令，而是普通命令，比如上一节的((...))算术运算，或者test命令与普通命令混用，那么可以使用 Bash 的命令控制操作符&amp;&amp;（AND）和||（OR），进行多个命令的逻辑运算。</p>
<pre><code class="language-bash">$ command1 &amp;&amp; command2
$ command1 || command2
</code></pre>
<p>对于&amp;&amp;操作符，先执行command1，只有command1执行成功后， 才会执行command2。对于||操作符，先执行command1，只有command1执行失败后， 才会执行command2。</p>
<pre><code class="language-bash">$ mkdir temp &amp;&amp; cd temp
</code></pre>
<p>上面的命令会创建一个名为temp的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<pre><code class="language-bash">$ [ -d temp ] || mkdir temp
</code></pre>
<p>上面的命令会测试目录temp是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<pre><code class="language-bash">[ ! -d temp ] &amp;&amp; exit 1
</code></pre>
<p>上面的命令中，如果temp子目录不存在，脚本会终止，并且返回值为1。</p>
<p>下面就是if与&amp;&amp;结合使用的写法。</p>
<pre><code class="language-bash">if [ condition ] &amp;&amp; [ condition ]; then
  command
fi
</code></pre>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#! /bin/bash

filename=$1
word1=$2
word2=$3

if grep $word1 $filename &amp;&amp; grep $word2 $filename
then
  echo &quot;$word1 and $word2 are both in $filename.&quot;
fi
</code></pre>
<p>上面的例子只有在指定文件里面，同时存在搜索词word1和word2，就会执行if的命令部分。</p>
<p>下面的示例演示如何将一个&amp;&amp;判断表达式，改写成对应的if结构。</p>
<pre><code class="language-bash">[[ -d &quot;$dir_name&quot; ]] &amp;&amp; cd &quot;$dir_name&quot; &amp;&amp; rm *

# 等同于

if [[ ! -d &quot;$dir_name&quot; ]]; then
  echo &quot;No such directory: '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! cd &quot;$dir_name&quot;; then
  echo &quot;Cannot cd to '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! rm *; then
  echo &quot;File deletion failed. Check results&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<h2 id="4-case-结构">4. case 结构</h2>
<p>case结构用于多值判断，可以为每个值指定对应的命令，跟包含多个elif的if结构等价，但是语义更好。它的语法如下。</p>
<pre><code class="language-bash">case expression in
  pattern )
    commands ;;
  pattern )
    commands ;;
  ...
esac
</code></pre>
<p>上面代码中，expression是一个表达式，pattern是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（;）结尾。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
case $character in
  1 ) echo 1
    ;;
  2 ) echo 2
    ;;
  3 ) echo 3
    ;;
  * ) echo 输入不符合要求
esac
</code></pre>
<p>上面例子中，最后一条匹配语句的模式是*，这个通配符可以匹配其他字符和没有输入字符的情况，类似if的else部分。</p>
<p>下面是另一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

OS=$(uname -s)

case &quot;$OS&quot; in
  FreeBSD) echo &quot;This is FreeBSD&quot; ;;
  Darwin) echo &quot;This is Mac OSX&quot; ;;
  AIX) echo &quot;This is AIX&quot; ;;
  Minix) echo &quot;This is Minix&quot; ;;
  Linux) echo &quot;This is Linux&quot; ;;
  *) echo &quot;Failed to identify this OS&quot; ;;
esac
</code></pre>
<p>上面的例子判断当前是什么操作系统。</p>
<p>case的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li>a)：匹配a。</li>
<li>a|b)：匹配a或b。</li>
<li>[[:alpha:]])：匹配单个字母。</li>
<li>???)：匹配3个字符的单词。</li>
<li>*.txt)：匹配.txt结尾。</li>
<li>*)：匹配任意输入，通过作为case结构的最后一个模式。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个字母或数字 &gt; &quot;
read character
case $character in
  [[:lower:]] | [[:upper:]] ) echo &quot;输入了字母 $character&quot;
                              ;;
  [0-9] )                     echo &quot;输入了数字 $character&quot;
                              ;;
  * )                         echo &quot;输入不符合要求&quot;
esac
</code></pre>
<p>上面例子中，使用通配符[[:lower:]] | [[:upper:]]匹配字母，[0-9]匹配数字。</p>
<p>Bash 4.0之前，case结构只能匹配一个条件，然后就会退出case结构。Bash 4.0之后，允许匹配多个条件，这时可以用;;&amp;终止每个条件块。</p>
<pre><code class="language-bash">#!/bin/bash
# test.sh

read -n 1 -p &quot;Type a character &gt; &quot;
echo
case $REPLY in
  [[:upper:]])    echo &quot;'$REPLY' is upper case.&quot; ;;&amp;
  [[:lower:]])    echo &quot;'$REPLY' is lower case.&quot; ;;&amp;
  [[:alpha:]])    echo &quot;'$REPLY' is alphabetic.&quot; ;;&amp;
  [[:digit:]])    echo &quot;'$REPLY' is a digit.&quot; ;;&amp;
  [[:graph:]])    echo &quot;'$REPLY' is a visible character.&quot; ;;&amp;
  [[:punct:]])    echo &quot;'$REPLY' is a punctuation symbol.&quot; ;;&amp;
  [[:space:]])    echo &quot;'$REPLY' is a whitespace character.&quot; ;;&amp;
  [[:xdigit:]])   echo &quot;'$REPLY' is a hexadecimal digit.&quot; ;;&amp;
esac
</code></pre>
<p>执行上面的脚本，会得到下面的结果。</p>
<pre><code class="language-bash">$ test.sh
Type a character &gt; a
'a' is lower case.
'a' is alphabetic.
'a' is a visible character.
'a' is a hexadecimal digit.
</code></pre>
<p>可以看到条件语句结尾添加了;;&amp;以后，在匹配一个条件之后，并没有退出case结构，而是继续判断下一个条件。</p>
<h2 id="5-参考链接">5. 参考链接</h2>
<p><a href="https://wangdoc.com/bash/condition.html">转载自</a><br>
<a href="http://linuxcommand.org/tlcl.php">The Linux Command Line</a>, William Shotts</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[neo服务更新]]></title>
        <id>https://chriswsq.github.io/post/neo-fu-wu-geng-xin/</id>
        <link href="https://chriswsq.github.io/post/neo-fu-wu-geng-xin/">
        </link>
        <updated>2020-11-23T06:03:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="neo服务更新">neo服务更新</h1>
<h2 id="清理旧数据">清理旧数据</h2>
<pre><code class="language-bash">docker rm -f    neo-cli

docker rmi neongd/neo-cli

find  /bsn/neo/ -type d | xargs rm -rf {} \;
</code></pre>
<h2 id="安装新版本neo">安装新版本neo</h2>
<pre><code class="language-bash">docker pull neongd/neo-cli

docker run --name=neo-cli -dit -p 10332-10334:10332-10334  -v /bsn/neo/chain.acc.zip:/neo-cli/chain.acc.zip -v /bsn/neo/ApplicationLogs_00746E41:/neo-cli/ApplicationLogs_00746E41 -v /bsn/neo/Chain_00746E41:/neo-cli/Chain_00746E41 -v /bsn/neo/Index_00746E41:/neo-cli/Index_00746E41 -v /bsn/neo/Nep5BalanceData:/neo-cli/Nep5BalanceData -v /bsn/neo/SystemAssetBalanceData:/neo-cli/SystemAssetBalanceData --restart=always neongd/neo-cli


docker exec -it neo-cli bash

screen -r node

install SimplePolicy
install RpcSecurity
install ApplicationLogs
install ImportBlocks
install RpcWallet
install RpcNep5Tracker
install RpcSystemAsseTtracker
install CoreMetrics
install StatesDumper


docker container restart neo-cli
</code></pre>
<h2 id="查看状态">查看状态</h2>
<p>两个值在变动则为正常</p>
<pre><code class="language-bash">docker exec -it neo-cli  bash

screen -r node 

show state
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[公链之oasis]]></title>
        <id>https://chriswsq.github.io/post/gong-lian-zhi-oasis/</id>
        <link href="https://chriswsq.github.io/post/gong-lian-zhi-oasis/">
        </link>
        <updated>2020-11-03T08:58:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="非验证节点">非验证节点</h2>
<p>填写绿洲P2P地址，同步公链数据</p>
<p>（普通节点）</p>
<h2 id="验证节点">验证节点</h2>
<p>需要创建实体，控制网络上的个人或组织的奖金</p>
<p>需要下载oasis app ，生成账户的公私钥</p>
<p>（共识节点）</p>
<h2 id="paratime节点">ParaTime节点</h2>
<p>目前还是测试版本</p>
<ol>
<li>
<p>要运行ParaTime节点，您必须已经是具有在网络上注册的实体ID的Oasis验证器。您可能已经在运行：</p>
<ul>
<li>
<p>一个或多个验证器节点</p>
<p>也就是需要至少有一个共识节点</p>
</li>
<li>
<p>可选的非验证者节点</p>
</li>
</ul>
</li>
</ol>
<h2 id="非验证节点-2">非验证节点</h2>
<p>根据实际需求我们需要使用非验证节点，但非验证节点启动时没有rpc端口，所以要借助网关来代理出去端<br>
口，</p>
<p>参考<br>
https://docs.oasis.dev/general/run-a-node/set-up-your-node/run-non-validator<br>
https://docs.oasis.dev/oasis-core/high-level-components/oasis-node/rpc<br>
https://docs.oasis.dev/general/oasis-network/network-parameters<br>
https://github.com/oasisprotocol/oasis-core/releases/tag/v20.10<br>
https://github.com/oasisprotocol/oasis-core-rosetta-gateway</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis]]></title>
        <id>https://chriswsq.github.io/post/redis/</id>
        <link href="https://chriswsq.github.io/post/redis/">
        </link>
        <updated>2020-10-31T09:29:16.000Z</updated>
        <content type="html"><![CDATA[<p>https://segmentfault.com/a/1190000022808576</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cita链管理服务部署]]></title>
        <id>https://chriswsq.github.io/post/cita-lian-guan-li-fu-wu-bu-shu/</id>
        <link href="https://chriswsq.github.io/post/cita-lian-guan-li-fu-wu-bu-shu/">
        </link>
        <updated>2020-10-29T08:32:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1链管理服务依赖环境">1.链管理服务依赖环境</h2>
<p>•	python &gt;= 3.7.9<br>
•	docker &gt;= 19.0</p>
<ol>
<li>安装3.7.9版本参考：<br>
https://blog.csdn.net/lkgCSDN/article/details/84403329<br>
https://chriswsq.github.io/post/elk-gao-jing-zhi-elastalert-bu-shu-ji-pei-zhi/</li>
</ol>
<p>ln -s  /usr/local/python3/bin/pip3  /usr/bin/pip3<br>
ln -s  /usr/local/python3  /usr/bin/python3<br>
ln -s /usr/local/python3/bin/gunicorn /usr/bin/gunicorn</p>
<h2 id="2链管理服务部署步骤">2.链管理服务部署步骤</h2>
<ul>
<li>解压源码包并进入目录</li>
</ul>
<pre><code class="language-bash">tar xzvf bsn-cita-chain-manager.tar.gz
cd bsn-cita-chain-manager
</code></pre>
<ul>
<li>
<p>安装依赖包<br>
<code>pip3 install -r requirements.txt -i https://pypi.douban.com/simple</code></p>
</li>
<li>
<p>生成pub_key、pri_key</p>
</li>
</ul>
<p>通过cita-cli工具，执行 ./cita-cli key create --algorithm sm2，将 address 字段写入pub_key，将 private 字段写入pri_key</p>
<ul>
<li>修改配置文件</li>
</ul>
<pre><code class="language-bash">vim conf/config.py

# 链节点密钥对的路径及文件名称
PUBKEY_PATH = '/opt/pub_key'
PRIKEY_PATH = '/opt/pri_key'

# cita 镜像名称，rebirth 镜像名称以及 rebirth 依赖 mysql 的镜像名称（下文详细说明）
CITA_IMAGE_VERSION = 'cita/cita-ee:1.3.1-sm2-sm3'
MYSQL_IMAGE_VERSION = 'cita-for-bsn-mysql:5.7'
REBIRTH_IMAGE_VERSION = 'cita-for-bsn-rebirth:0.1'

# 链管理服务产生链配置的目录
CHAIN_CONFIG_PATH = '/opt/all-chain-config'

# 链节点 TLS 证书所在目录
TLS_PATH = '/opt'

# solc 编译器镜像名称
SOLC_IMAGE_VERSION = 'ethereum/solc:0.4.24'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker-compsoe部署kafka集群]]></title>
        <id>https://chriswsq.github.io/post/docker-compsoe-bu-shu-kafka-ji-qun/</id>
        <link href="https://chriswsq.github.io/post/docker-compsoe-bu-shu-kafka-ji-qun/">
        </link>
        <updated>2020-10-16T10:00:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>kafka依赖于zookeeper存放元数据, 所以在创建kafka集群之前需要创建zookeeper; 更多关于zookeeper集群创建见: 使用Docker部署zookeeper集群</p>
<h2 id="拉取镜像">拉取镜像</h2>
<pre><code class="language-bash">docker pull zookeeper:3.4
docker pull zookeeper:3.4 docker pull wurstmeister/kafka_2.13-2.6.0
</code></pre>
<blockquote>
<p>其中kafka版本中的2.12为Scala版本</p>
</blockquote>
<h2 id="创建子网段">创建子网段</h2>
<pre><code class="language-bash">docker network create --subnet 172.30.1.0/16 --gateway 172.30.0.1 kafka
</code></pre>
<pre><code class="language-yaml">version: '3'

services: 
    zoo1:
        image: zookeeper:3.4
        restart: always
        hostname: zoo1
        container_name: zoo1
        ports:
            - 2184:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo1/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo1/datalog:/datalog
        environment: 
            ZOO_MY_ID: 1
            ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.11

    zoo2:
        image: zookeeper:3.4
        restart: always
        hostname: zoo2
        container_name: zoo2
        ports:
            - 2185:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo2/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo2/datalog:/datalog
        environment: 
            ZOO_MY_ID: 2
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zoo3:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.12

    zoo3:
        image: zookeeper:3.4
        restart: always
        hostname: zoo3
        container_name: zoo3
        ports:
            - 2186:2181
        volumes: 
            - /home/zk/workspace/volumes/zkcluster/zoo3/data:/data
            - /home/zk/workspace/volumes/zkcluster/zoo3/datalog:/datalog
        environment: 
            ZOO_MY_ID: 3
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=0.0.0.0:2888:3888
        networks:
            kafka:
                ipv4_address: 172.30.0.13

    kafka1:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka1
        container_name: kafka1
        privileged: true
        ports:
            - 9092:9092
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka1
              KAFKA_LISTENERS: PLAINTEXT://kafka1:9092
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:9092
              KAFKA_ADVERTISED_PORT: 9092
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka1/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.11
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13
        depends_on: 
            - zoo1
            - zoo2
            - zoo3
        external_links: 
            - zoo1
            - zoo2
            - zoo3

    kafka2:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka2
        container_name: kafka2
        privileged: true
        ports:
            - 9093:9093
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka2
              KAFKA_LISTENERS: PLAINTEXT://kafka2:9093
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka2:9093
              KAFKA_ADVERTISED_PORT: 9093
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka2/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.12
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13                
        depends_on: 
            - zoo1
            - zoo2
            - zoo3                
        external_links: 
            - zoo1
            - zoo2
            - zoo3           

    kafka3:
        image: wurstmeister/kafka
        restart: always
        hostname: kafka3
        container_name: kafka3
        privileged: true
        ports:
            - 9094:9094
        environment:
              KAFKA_ADVERTISED_HOST_NAME: kafka3
              KAFKA_LISTENERS: PLAINTEXT://kafka3:9094
              KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka3:9094
              KAFKA_ADVERTISED_PORT: 9094
              KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181
        volumes:
            - /home/zk/workspace/volumes/kafkaCluster/kafka3/logs:/kafka
        networks:
            kafka:
                ipv4_address: 172.30.1.13
        extra_hosts: 
            - zoo1:172.30.0.11
            - zoo2:172.30.0.12
            - zoo3:172.30.0.13                
        depends_on: 
            - zoo1
            - zoo2
            - zoo3                
        external_links: 
            - zoo1
            - zoo2
            - zoo3

networks: 
  kafka:
     ipam:
       config:
         - subnet: 172.30.0.0/16
</code></pre>
<blockquote>
<p>在kafka服务中声明了depends_on, 所以在所有zookeeper启动之后才会真正启动kafka容器</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loki配置邮件告警]]></title>
        <id>https://chriswsq.github.io/post/loki-pei-zhi-you-jian-gao-jing/</id>
        <link href="https://chriswsq.github.io/post/loki-pei-zhi-you-jian-gao-jing/">
        </link>
        <updated>2020-10-12T09:43:07.000Z</updated>
        <summary type="html"><![CDATA[<p>监控的目的就是及时发现问题去解决处理，那么在告警就是必不可少的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>监控的目的就是及时发现问题去解决处理，那么在告警就是必不可少的。</p>
<!-- more -->
<p>本次告警配置是loki结合grafana来进行邮件告警</p>
<h2 id="grafana配置告警">grafana配置告警</h2>
<p>1.通过标签定位到需要查看的服务,并通过关键字过滤出想要查看的日志内容<br>
<img src="https://chriswsq.github.io/post-images/1602669342426.png" alt="" loading="lazy"></p>
<p>为尽快得到告警邮件这里我们设置带有info字符的日志</p>
<p>2.看下过去一段时间内，日志中带有info字段的趋势<br>
<img src="https://chriswsq.github.io/post-images/1602496164171.png" alt="" loading="lazy"></p>
<p>这里可以看到，日志在不停的打印带有info字段的日志</p>
<p>在数据源中添加一个Prometheus类型，并在地址栏中填写上http://loki:3100/loki ,这样我们就能通过像查询prometheus一样查询日志的走势<br>
<img src="https://chriswsq.github.io/post-images/1602496373242.png" alt="" loading="lazy"></p>
<p>这时候再创建一个pannel来查询info日志的趋势就可以得到如下结果：</p>
<figure data-type="image" tabindex="1"><img src="https://chriswsq.github.io/post-images/1602496436562.png" alt="" loading="lazy"></figure>
<p>接下来的工作，就是在Grafana上添加一个Alert小铃铛，让它每分钟去Loki里面查询有没有出现info字段的日志出现，如果计算出来的结果大于0，就让Grafana通过邮件告警出来。</p>
<figure data-type="image" tabindex="2"><img src="https://chriswsq.github.io/post-images/1602496637970.png" alt="" loading="lazy"></figure>
<p>配置完成后不急保存，我们先Test rule看看rule是否能生效。</p>
<p><img src="https://chriswsq.github.io/post-images/1602496687577.png" alt="" loading="lazy"><br>
看到state:&quot;alerting&quot; 说明现在已经开始报警了</p>
<h2 id="grafana配置邮件">grafana配置邮件</h2>
<pre><code class="language-ini">[smtp]
enabled = true
host = smtp.163.com:25
user = 你的邮箱
# If the password contains # or ; you have to wrap it with triple quotes. Ex &quot;&quot;&quot;#password;&quot;&quot;&quot;
password = 你的密码
;cert_file =
;key_file =
;skip_verify = false
from_address = 你的邮箱
from_name = Grafana
</code></pre>
<p>修改后，保存退出，重启grafana服务</p>
<ul>
<li>登入grafana页面</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://chriswsq.github.io/post-images/1602496941499.png" alt="" loading="lazy"></figure>
<ul>
<li>创建邮件发送规则</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://chriswsq.github.io/post-images/1602497009120.png" alt="" loading="lazy"></figure>
<p>可以为不同的业务组创建不同的通知通道，例如，运维通道为Ops，研发为Dev。然后可以为一个Metrics指定多个通知通道。</p>
<p>Name为通道名称</p>
<p>Type为通道类型，此处选Email，也可选择钉钉告警或者Alert Manager等告警类型。</p>
<p>Default(send on all alerts)开启后，表示在所有Graph Panel中配置告警规则时默认都会选用此通道。该选项默认为关闭。</p>
<p>Include image开启后，表示是发送告警图片。</p>
<p>Disable Resove Message开启后，表示发送恢复邮件，默认关闭。</p>
<p>Send reminders开启后，还需设置下方的发送间隔，表示发送告警邮件的间隔，默认关闭表示若某个告警发生后即使持续很长时间也仅发送一次邮件。</p>
<p>多个邮箱地址间用分号&quot;;&quot;隔开。例：xxx@163.com;xxx@qq.com</p>
<p>创建成功后，点击Send Test 按钮，测试邮件是否能发送成功。（如果发送不成功，可在grafana.log中查看日志信息）</p>
<ul>
<li>在告警中添加配置的告警邮件联系人组</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chriswsq.github.io/post-images/1602497296964.png" alt="" loading="lazy"></figure>
<ul>
<li>收到告警邮件</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://chriswsq.github.io/post-images/1602497366975.png" alt="" loading="lazy"></figure>
<p>也可以发送图片 ,根据提示安装插件即可<br>
<img src="https://chriswsq.github.io/post-images/1602497453813.png" alt="" loading="lazy"></p>
<p>安装图片插件 官方建议单独新建一个容器去取加载插件而非直接在grafana容器中安装插件</p>
<pre><code class="language-yaml">version: '2'

services:
  grafana:
    image: grafana/grafana:7.0.0-beta1
    ports:
      - 3000
    environment:
      GF_RENDERING_SERVER_URL: http://renderer:8081/render
      GF_RENDERING_CALLBACK_URL: http://grafana:3000/
      GF_LOG_FILTERS: rendering:debug
  renderer:
    image: grafana/grafana-image-renderer:2.0.0-beta1
    ports:
      - 8081
    environment:
      ENABLE_METRICS: 'true'
</code></pre>
<p>结果为<br>
<img src="https://chriswsq.github.io/post-images/1602668961665.png" alt="" loading="lazy"></p>
<p>参考文档：<br>
https://grafana.com/blog/2020/05/07/grafana-7.0-preview-new-image-renderer-plugin-to-replace-phantomjs/<br>
https://www.jianshu.com/p/0982a8ee204c</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[轻量级日志系统Loki原理简介和使用]]></title>
        <id>https://chriswsq.github.io/post/qing-liang-ji-ri-zhi-xi-tong-loki-yuan-li-jian-jie-he-shi-yong/</id>
        <link href="https://chriswsq.github.io/post/qing-liang-ji-ri-zhi-xi-tong-loki-yuan-li-jian-jie-he-shi-yong/">
        </link>
        <updated>2020-10-12T05:40:24.000Z</updated>
        <content type="html"><![CDATA[<pre><code> 目前公司未采用传统的zabbix对服务器监控，而采用了prometheus。以前监控日志的时候是采用
</code></pre>
<p>elastalert+logstash+kibana+filebeat+zookeeper+kafka 来做日志方面的监控告警。后来了解到有loki这样一个日志系统，上网搜了一番资料做了一些对比</p>
<h2 id="日志监控系统elkloki">日志监控系统elk，loki</h2>
<h3 id="elk">ELK</h3>
<p>优势：<br>
1、功能丰富，允许复杂的操作（增减字段，调整字段书序，数据json化）<br>
劣势：<br>
1、主流的ELK（全文检索）或者EFK比较重<br>
2、ES复杂的搜索功能很多都用不上 规模复杂，资源占用高，操作苦难<br>
大多数查询只关注一定时间范围和一些简单的参数（如host、service等）<br>
3、Kibana和Grafana之间切换，影响用户体验<br>
4、倒排索引的切分和共享的成本较高</p>
<h3 id="loki">Loki</h3>
<p>1、最小化度量和日志的切换成本<br>
有助于减少异常事件的响应时间和提高用户的体验<br>
2、在查询语言的易操作性和复杂性之间可以达到一个权衡<br>
3、更具成本效益</p>
<h2 id="项目主页">项目主页</h2>
<p>https://github.com/grafana/loki</p>
<h2 id="loki组件介绍">loki组件介绍</h2>
<h3 id="promtail">Promtail</h3>
<p>用来将容器日志发送到 Loki 或者 Grafana 服务上的日志收集工具<br>
该工具主要包括发现采集目标以及给日志流添加上 Label 标签 然后发送给 Loki<br>
Promtail 的服务发现是基于 Prometheus 的服务发现机制实现的</p>
<h3 id="loki-2">Loki</h3>
<p>受 Prometheus 启发的可以水平扩展、高可用以及支持多租户的日志聚合系统<br>
使用了和 Prometheus 相同的服务发现机制，将标签添加到日志流中而不是构建全文索引<br>
从 Promtail 接收到的日志和应用的 metrics 指标就具有相同的标签集<br>
不仅提供了更好的日志和指标之间的上下文切换，还避免了对日志进行全文索引</p>
<h3 id="grafana">Grafana</h3>
<p>一个用于监控和可视化观测的开源平台<br>
支持非常丰富的数据源<br>
在 Loki 技术栈中它专门用来展示来自 Prometheus 和 Loki 等数据源的时间序列数据<br>
可进行查询、可视化、报警等操作<br>
可以用于创建、探索和共享数据 Dashboard<br>
鼓励数据驱动</p>
<h2 id="安装loki">安装loki</h2>
<p>这里我使用docker 安装，下面是compose文件</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  loki:
    image: &quot;grafana/loki:1.5.0&quot;
    container_name: &quot;loki&quot;
    restart: &quot;always&quot;
    volumes:
      - &quot;/etc/localtime:/etc/localtime&quot;
      - &quot;/usr/local/src/loki/:/etc/loki&quot;
      - &quot;./loki:/loki&quot;
    ports:
      - &quot;3100:3100&quot;
    command: &quot;-config.file=/etc/loki/local-config.yaml&quot;
</code></pre>
<p>记得要修改loki文件夹的所有者为 10001 不然会提示权限不足</p>
<p><code>chown -Rf 10001:10001 loki</code></p>
<p>之后使用docker-compose启动</p>
<p><code>docker-compose up -d</code></p>
<p>就这样loki的服务端就ok了，下面说下几个坑，第一个是</p>
<pre><code class="language-bash">^[level=warn ts=2020-07-06T06:54:12.754273854Z caller=client.go:242 component=client host=192.179.11.1:3100 msg=&quot;error sending batch, will retry&quot; status=429 error=&quot;server returned HTTP status 429 Too Many Requests (429): Ingestion rate limit exceeded (limit: 6291456 bytes/sec) while attempting to ingest '221' lines totaling '101946' bytes, reduce log volume or contact your Loki administrator to see if the limit can be increased&quot;
</code></pre>
<p>当你搭建完成promtail，并且启动发送日志到loki的时候很有可能会碰到这个错误，因为你要收集的日志太多了，超过了loki的限制，所以会报429，如果你要增加限制可以修改loki的配置文件,在limits_config中添加</p>
<p><code>ingestion_rate_mb: 15</code></p>
<p>如果你是老版本的loki，那么是添加</p>
<p><code>ingestion_rate: 25000</code></p>
<p>详细可以看下面</p>
<p>https://github.com/grafana/loki/pull/1278/files/f468d5d258a42316036290fad1b795c40bec22e4#diff-935fd110763ed3367d3ea740a3d3c072</p>
<p>还有一个坑是<br>
<code>level=error ts=2020-07-06T03:58:02.217480067Z caller=client.go:247 component=client host=192.179.11.1:3100 msg=&quot;final error sending batch&quot; status=400 error=&quot;server returned HTTP status 400 Bad Request (400): entry for stream '{app=\&quot;app_error\&quot;, filename=\&quot;/error.log\&quot;, host=\&quot;192.179.11.12\&quot;}' has timestamp too new: 2020-07-06 03:58:01.175699907 +0000 UTC&quot;</code><br>
这个是两台机器的时间相差太大了，我promtail这台机器的时间没有和ntp服务器同步时间，所以就报了这个错误，只要把时间都同步了就好了</p>
<p><strong>我的最终配置文件</strong></p>
<pre><code class="language-yaml">auth_enabled: false

server:
  http_listen_port: 3100

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
    final_sleep: 0s
  chunk_idle_period: 5m
  chunk_retain_period: 30s

schema_config:
  configs:
    - from: 2020-10-12
      store: boltdb
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 168h

storage_config:
  boltdb:
    directory: /loki/index

  filesystem:
    directory: /loki/chunks

limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h
  ingestion_rate_mb: 15

chunk_store_config:
  max_look_back_period: 0s

table_manager:
  retention_deletes_enabled: true
  retention_period: 336h
</code></pre>
<h2 id="安装promtail">安装promtail</h2>
<p>这里我使用docker 安装，下面是compose文件</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  promtail:
    image: grafana/promtail:1.5.0
    container_name: promtail
    restart: always
    volumes:
      - $PWD:/etc/promtail
      - /bsn/xuperchain/output/logs/xchain.log:/bsn/xuperchain/output/logs/xchain.log
    command:
      -config.file=/etc/promtail/promtail-docker-config.yaml
</code></pre>
<p><strong>配置文件如下</strong></p>
<pre><code class="language-yaml">server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: ./positions.yaml

clients:
  - url: http://192.168.40.6:3100/loki/api/v1/push

scrape_configs:
 - job_name: xuperchain
   static_configs:
   - labels:
      app: local_xchain
      host: 192.168.40.7
      env: prod
      __path__: /bsn/xuperchain/output/logs/xchain.log
</code></pre>
<p>之后使用docker-compose启动</p>
<p><code>docker-compose up -d</code></p>
<h2 id="安装grafana">安装grafana</h2>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  grafana:
    image: grafana/grafana:7.1.5
    container_name: grafana
    restart: always
    volumes:
     - /bsn/prometheus/grafana:/var/lib/grafana
     - /bsn/prometheus/grafana/grafana.ini:/etc/grafana/grafana.ini
     - /etc/localtime:/etc/localtime
    ports:
     - 3000:3000
</code></pre>
<p><strong>配置文件</strong><br>
下载一个grafana的tar包用即可，也可下载镜像后拷出来grafana.ini文件即可</p>
<p><strong>访问grafana界面</strong></p>
<p>http://192.168.40.6:3000/</p>
<figure data-type="image" tabindex="1"><img src="https://chriswsq.github.io/post-images/1602485759409.png" alt="" loading="lazy"></figure>
<p>默认的登陆账号 admin/admin</p>
<p>然后添加loki数据源<br>
<img src="https://chriswsq.github.io/post-images/1602485889822.png" alt="" loading="lazy"></p>
<p>url添加  http://192.168.40.6:3100<br>
<img src="https://chriswsq.github.io/post-images/1602485944668.png" alt="" loading="lazy"></p>
<p>点击Exporter 选择loki选择相应的label</p>
<figure data-type="image" tabindex="2"><img src="https://chriswsq.github.io/post-images/1602486257770.png" alt="" loading="lazy"></figure>
<h2 id="loki-日志查询语言">Loki 日志查询语言</h2>
<p>基本的LogQL查询由两部分组成：log stream selector、filter expression</p>
<h3 id="log-stream-selector">Log stream selector</h3>
<p>它由一个或多个键值对组成，每个键是一个日志标签，值的话是标签的值，例如<br>
<code>{app=&quot;local_xchain&quot;,host=&quot;192.168.40.7&quot;}</code></p>
<p>在这个例子中，记录具有的标签流app，其值是local_xhcain和的一个标签host，它的值192.168.40.7将被包括在查询结果。注意，这将匹配其标签至少 包含192.168.40.7其名称标签的任何日志流；如果有多个包含该标签的流，则所有匹配流的日志将显示在结果中。</p>
<p>支持以下标签匹配运算符：</p>
<p>=：完全相等。<br>
!=：不相等。<br>
=~：正则表达式匹配。<br>
!~：正则表达式不匹配。</p>
<p>适用于Prometheus标签选择器的相同规则也适用 于Loki日志流选择器。</p>
<p>Filter expression<br>
写入日志流选择器后，可以使用搜索表达式进一步过滤生成的日志集。搜索表达式可以只是文本或正则表达式：</p>
<ul>
<li>{job=“mysql”} |= “error”</li>
<li>{name=“kafka”} |~ “tsdb-ops.*io:2003”</li>
<li>{instance=~“kafka-[23]”,name=“kafka”} != kafka.server:type=ReplicaManager</li>
</ul>
<p>运算符说明</p>
<ul>
<li>|=：日志行包含字符串。</li>
<li>!=：日志行不包含字符串。</li>
<li>|~：日志行匹配正则表达式。</li>
<li>!~：日志行与正则表达式不匹配。</li>
</ul>
<h3 id="指标查询">指标查询</h3>
<h4 id="范围向量">范围向量</h4>
<p>LogQL 与Prometheus 具有相同的范围向量概念，不同之处在于所选的样本范围包括每个日志条目的值1。可以在所选范围内应用聚合，以将其转换为实例向量。</p>
<p><strong>注：对于此种查询，需要添加数据源，选择promethes，但是地址为loki的地址，并在最后添加/lok即可</strong></p>
<p>当前支持的操作功能为：</p>
<ul>
<li>rate：计算每秒的条目数</li>
<li>count_over_time：计算给定范围内每个日志流的条目。</li>
</ul>
<p>//对fluent-bit作业在最近五分钟内的所有日志行进行计数。</p>
<p><code>count_over_time({job=&quot;fluent-bit&quot;}[5m])</code></p>
<p>获取fluent-bit作业在过去十秒内所有非超时错误的每秒速率。</p>
<p><code>rate({job=&quot;fluent-bit&quot;} |= &quot;error&quot; != &quot;timeout&quot; [10s]</code></p>
<h4 id="集合运算符">集合运算符</h4>
<p>与PromQL一样，LogQL支持内置聚合运算符的一个子集，可用于聚合单个向量的元素，从而产生具有更少元素但具有集合值的新向量：</p>
<ul>
<li>sum：计算标签上的总和</li>
<li>min：选择最少的标签</li>
<li>max：选择标签上方的最大值</li>
<li>avg：计算标签上的平均值</li>
<li>stddev：计算标签上的总体标准差</li>
<li>stdvar：计算标签上的总体标准方差</li>
<li>count：计算向量中元素的数量</li>
<li>bottomk：通过样本值选择最小的k个元素</li>
<li>topk：通过样本值选择最大的k个元素</li>
</ul>
<p>可以通过包含a without或 by子句，使用聚合运算符聚合所有标签值或一组不同的标签值：</p>
<p><code>&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</code></p>
<p>举例：</p>
<p>统计最高日志吞吐量按container排序前十的应用程序<br>
<code>topk(10,sum(rate({job=&quot;fluent-bit&quot;}[5m])) by(container))</code></p>
<p>获取最近五分钟内的日志计数，按级别分组<br>
<code>sum(count_over_time({job=&quot;fluent-bit&quot;}[5m])) by (level)</code></p>
<p>更多内容请参考：https://github.com/grafana/loki/blob/master/docs/logql.md</p>
<p>参考文档：<br>
https://blog.csdn.net/weixin_44267608/article/details/105264432<br>
https://segmentfault.com/a/1190000023379491<br>
https://www.bboy.app/2020/07/08/%E4%BD%BF%E7%94%A8loki%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xuperchian  建链未成功手动修复]]></title>
        <id>https://chriswsq.github.io/post/xuperchian change Common node/</id>
        <link href="https://chriswsq.github.io/post/xuperchian change Common node/">
        </link>
        <updated>2020-09-18T03:04:41.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>从idc服务器日志中找到 链名的日志  会有创建该链的json文件</p>
<p>#手动修复</p>
<pre><code>#step 1. 创建群组
./xchain-cli wasm invoke group_chain --method addChain -a '{&quot;bcname&quot;:&quot;CounterChain1&quot;}'

#step 2. 添加节点
./xchain-cli wasm invoke group_chain --method addNode -a '{&quot;bcname&quot;:&quot;CounterChain1&quot;, &quot;ip&quot;:&quot;/ip4/127.0.0.1/tcp/47101/p2p/QmVxeNubpg1ZQjQT8W5yZC9fD7ZB1ViArwvyGUB53sqf8e&quot;, 

#step 3. 创建平行链
./xchain-cli transfer --to CounterChain1 --amount 100 --desc createCounterChain1.json


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xuperchian 增减共识节点、添加群组操作步骤]]></title>
        <id>https://chriswsq.github.io/post/xuperchian-change-Common-node/</id>
        <link href="https://chriswsq.github.io/post/xuperchian-change-Common-node/">
        </link>
        <updated>2020-09-15T11:19:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="加入群组">加入群组</h1>
<h2 id="查看当前群组节点">查看当前群组节点</h2>
<pre><code class="language-bash">./xchain-cli wasm query group_chain --method listNode -a '{&quot;bcname&quot;:&quot;app000120200824165811835422&quot;}'
</code></pre>
<h2 id="节点加入群组">节点加入群组</h2>
<pre><code class="language-bash">./xchain-cli wasm invoke group_chain --method addNode -a '{&quot;bcname&quot;:&quot;app000120200824165811835422&quot;, &quot;ip&quot;:&quot;/ip4/192.168.40.6/tcp/40001/p2p/QmY7UxwcLpD8QK8p6gAk99xuz3Q16jcaCoU8iMokVWYa83&quot;, &quot;address&quot;:&quot;2B1rDQhq7W4TStSHoD88N1SUYXrCDV821v&quot;}'
</code></pre>
<blockquote>
<p>将bcname 、ip 、 address改为实际的参数即可</p>
</blockquote>
<h1 id="更改共识节点">更改共识节点</h1>
<h2 id="查询金额">查询金额</h2>
<pre><code class="language-bash">./xchain-cli account balance zALW2YRp55LFuro1uAjgfoGTqCjgz3nHc --name app000120200824165811835422
</code></pre>
<h2 id="查看块高">查看块高</h2>
<pre><code class="language-bash">./xchain-cli status -H 127.0.0.1:37101 | jq '.blockchains[] | {&quot;name&quot;:.name,&quot;height&quot;:.ledger.trunkHeight}' | grep -A 1 app000120200824165811835422
</code></pre>
<h2 id="提案">提案</h2>
<pre><code class="language-bash">./xchain-cli transfer --to scocy5ZTaFykhRGGYxN9KSEkpxCD1cd72 --desc proposal_app000120200824165811835422.json  --amount 1  --name app000120200824165811835422

ae074dc967e0a03b81346a8e4796b01fe15b51472d3ba34f191d6b08e24a1918
</code></pre>
<h2 id="投票">投票</h2>
<pre><code class="language-bash">./xchain-cli vote ae074dc967e0a03b81346a8e4796b01fe15b51472d3ba34f191d6b08e24a1918 --frozen 138160 --amount 52000000071795360000   --name app000120200824165811835422

74217bf729af8fc1b6acfbc5f953fbda029fb9078360ec301dfc113e690ac016
</code></pre>
<h2 id="查看交易内容">查看交易内容</h2>
<pre><code class="language-bash">./xchain-cli tx query  74217bf729af8fc1b6acfbc5f953fbda029fb9078360ec301dfc113e690ac016
</code></pre>
<h2 id="查看共识节点">查看共识节点</h2>
<pre><code class="language-bash">./xchain-cli tdpos status --name   app000120200824165811835422
</code></pre>
<h1 id="提案内容">提案内容</h1>
<pre><code class="language-json">{
    &quot;module&quot;: &quot;proposal&quot;,
    &quot;method&quot;: &quot;Propose&quot;,
    &quot;args&quot; : {
        &quot;min_vote_percent&quot;: 51,
        &quot;stop_vote_height&quot;: 688970
    },
    &quot;trigger&quot;: {
        &quot;height&quot;: 688980,
        &quot;module&quot;: &quot;consensus&quot;,
        &quot;method&quot;: &quot;update_consensus&quot;,
        &quot;args&quot; : {
            &quot;name&quot;: &quot;tdpos&quot;,
            &quot;config&quot;: {
                &quot;version&quot;:&quot;20&quot;,
                &quot;proposer_num&quot;:&quot;2&quot;,
                &quot;period&quot;:&quot;5000&quot;,
                &quot;alternate_interval&quot;:&quot;5000&quot;,
                &quot;term_interval&quot;:&quot;10000&quot;,
                &quot;block_num&quot;:&quot;720&quot;,
                &quot;vote_unit_price&quot;:&quot;1&quot;,
                &quot;init_proposer&quot;: {
                    &quot;1&quot;:[&quot;scocy5ZTaFykhRGGYxN9KSEkpxCD1cd72&quot;, &quot;qaXhH7gJcdfpapmWkbHdLNqUFq3Vst6Am&quot;]
                }
            }
        }
    }
}
</code></pre>
<blockquote>
<p>注意： 以上将 address、p2p、proposer_num等改为实际数据即可<br>
命令添加群组，一次性添加两个以上群组 不生效,须一个一个添加<br>
用命令行创建平行链，如果命令写错不报命令的错误，而会报其他的问题    例如 地址不在白名单<br>
后续加入群组的节点，需要重启才会同步块数据<br>
在进行提案的时候经常会导致xuper链或其他调整的链快高不一致的情况，这时候重启解决问题<br>
如果同一个链既要增加节点又要删减节点，那么是需要分开提案来做的</p>
</blockquote>
<pre><code class="language-bash">new
pJsfQecriScf4ZA6MHhjEpMMAiBbct5Sv
24rqLhCMozBJrmsXhtrR68wLAr72zDfuEL
qJV7qfGdf2GAZUcrx6v71ahQ69nYYWGpa


huainan2
app0001202007302056480751681 

2A8cTP6dFjKoZPXyCx7T5APbQKCUzbgBsx
pecX9eVDd368J3GBfdPNtVUgnTu4nvD7b
28HsYtaS1p7DqZ3QqXzCSsEk47dX4seU6o

app0001202007310000590617583

2A8cTP6dFjKoZPXyCx7T5APbQKCUzbgBsx
27xoBigJ6HRqtqQtohvaoMyBt55uECtNbV
sMbiWCdbiAHn84p77zjepAzGn3F7ztzAD


app0001202008011331415497000
2A8cTP6dFjKoZPXyCx7T5APbQKCUzbgBsx
pecX9eVDd368J3GBfdPNtVUgnTu4nvD7b
qaXhH7gJcdfpapmWkbHdLNqUFq3Vst6Am




</code></pre>
]]></content>
    </entry>
</feed>