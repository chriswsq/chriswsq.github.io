<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriswsq.github.io</id>
    <title>chris&apos;wang</title>
    <updated>2021-02-04T02:40:49.037Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriswsq.github.io"/>
    <link rel="self" href="https://chriswsq.github.io/atom.xml"/>
    <subtitle>当你觉得无所事事时，那你就是在虚度光阴</subtitle>
    <logo>https://chriswsq.github.io/images/avatar.png</logo>
    <icon>https://chriswsq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, chris&apos;wang</rights>
    <entry>
        <title type="html"><![CDATA[跨连]]></title>
        <id>https://chriswsq.github.io/post/kua-lian/</id>
        <link href="https://chriswsq.github.io/post/kua-lian/">
        </link>
        <updated>2021-02-02T06:01:50.000Z</updated>
        <content type="html"><![CDATA[<p>cjq   调用   relayer 服务<br>
cjq   负责人  lyk<br>
relayer 负责人  yz</p>
<p>目前一般报错</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rabbitmq基本知识]]></title>
        <id>https://chriswsq.github.io/post/rabbitmq-ji-ben-zhi-shi/</id>
        <link href="https://chriswsq.github.io/post/rabbitmq-ji-ben-zhi-shi/">
        </link>
        <updated>2021-01-12T07:04:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="功能介绍">功能介绍</h2>
<p>一般情况下，我们会使用 rabbitmq_management 插件，通过 Web UI 的方式来监控和操作 RabbitMQ（端口 15672），但有时候命令的方式会更加方便一些，RabbitMQ 提供了 CLI 管理工具 rabbitmqadmin ，其实就是基于 RabbitMQ 的 HTTP API，用 Python 写的一个脚本。</p>
<p><strong>rabbitmqadmin 提供了下面功能：</strong></p>
<ul>
<li>列出 exchanges, queues, bindings, vhosts, users, permissions, connections<br>
and channels。</li>
<li>创建和删除 exchanges, queues, bindings, vhosts, users and permissions。</li>
<li>发布和获取消息，以及消息详情。</li>
<li>关闭连接和清空队列。</li>
<li>导入导出配置。</li>
</ul>
<p>使用 rabbitmqadmin 的时候，我们需要理解 RabbitMQ 的基本概念，先回顾一下：</p>
<h2 id="rabbitmq-概念">RabbitMQ 概念：</h2>
<table>
<thead>
<tr>
<th>概念</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exchange</td>
<td>消息交换机，它指定消息按什么规则，路由到哪个队列</td>
</tr>
<tr>
<td>Queue</td>
<td>消息队列，每个消息都会被投入到一个或多个队列</td>
</tr>
<tr>
<td>Binding</td>
<td>绑定，它的作用就是把 exchange 和 queue 按照路由规则绑定起来</td>
</tr>
<tr>
<td>Routing Key</td>
<td>路由关键字，exchange 根据这个关键字进行消息投递</td>
</tr>
<tr>
<td>Vhost</td>
<td>虚拟主机，可以开设多个 vhost，用作不同用户的权限分离</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，就是投递消息的程序</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，就是接受消息的程序</td>
</tr>
<tr>
<td>Channel</td>
<td>消息通道，在客户端的每个连接里，可建立多个 channel，每个 channel 代表一个会话任务</td>
</tr>
</tbody>
</table>
<h2 id="rabbitmq-投递过程">RabbitMQ 投递过程：</h2>
<ol>
<li>客户端连接到消息队列服务器，打开一个 channel。</li>
<li>客户端声明一个 exchange，并设置相关属性。</li>
<li>客户端声明一个 queue，并设置相关属性。</li>
<li>客户端使用 routing key，在 exchange 和 queue 之间建立好绑定关系。</li>
<li>客户端投递消息到 exchange。</li>
<li>客户端从指定的 queue 中消费信息。</li>
</ol>
<h2 id="基本命令">基本命令</h2>
<p>创建一个test队列：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin declare queue name=test durable=true
queue declared
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 0        |
+------+----------+
</code></pre>
<p>需要注意：durable=true表示持久化，如果没有创建 Exchange，RabbitMQ 会使用默认的 Exchange，以及创建一个 Binding，这也就是为什么下面发布消息，可以成功的原因。</p>
<p>发布一条消息：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin publish routing_key=test payload=&quot;hello world&quot;
Message published
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 1        |
+------+----------+
</code></pre>
<p>消费一条消息（查看消息内容）：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin get queue=test requeue=true
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
| routing_key | exchange | message_count |   payload   | payload_bytes | payload_encoding | properties | redelivered |
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
| test        |          | 0             | hello world | 11            | string           |            | False       |
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 1        |
+------+----------+
[root@node1 ~]# rabbitmqadmin get queue=test requeue=false
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
| routing_key | exchange | message_count |   payload   | payload_bytes | payload_encoding | properties | redelivered |
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
| test        |          | 0             | hello world | 11            | string           |            | True        |
+-------------+----------+---------------+-------------+---------------+------------------+------------+-------------+
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 0        |
+------+----------+
</code></pre>
<p>需要注意：requeue=true表示查看队列，不消费；requeue=false表示查看队列，进行消费。</p>
<p>我们查看下上面创建队列后，默认创建的 Binding：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin list bindings
+--------+-------------+-------------+
| source | destination | routing_key |
+--------+-------------+-------------+
|        | test        | test        |
+--------+-------------+-------------+
</code></pre>
<p>可以看到，使用的默认 Exchange 是空字符串（系统中的第一个 Exchange，Binding 中的 source 部分），并且这个默认的 Exchange 是direct类型（也就是一对一模式），这种隐式调用确保了消息准确投递。</p>
<p>另外，再说一下 Binding 中的三个概念：</p>
<ul>
<li>Source：源头的意思，其实就是 Exchange。</li>
<li>destination：目的地的意思，其实就是 Queue。</li>
<li>routing_key：路由键的规则，用于 Queue 匹配（比如test.#）。<br>
那下面我们就手动创建一下 Exchange：</li>
</ul>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin declare exchange name=my.topic type=topic
exchange declared
[root@node1 ~]# rabbitmqadmin list exchanges
+--------------------+---------+
|        name        |  type   |
+--------------------+---------+
|                    | direct  |
| amq.direct         | direct  |
| amq.fanout         | fanout  |
| amq.headers        | headers |
| amq.match          | headers |
| amq.rabbitmq.log   | topic   |
| amq.rabbitmq.trace | topic   |
| amq.topic          | topic   |
| my.topic           | topic   |
+--------------------+---------+
</code></pre>
<p>需要注意：这边我们只创建了一个 Exchange，类型为 Topic，和之前创建的test队列，目前没有任何关系。</p>
<p>然后再创建一个 Binding：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin declare binding source=my.topic destination=test routing_key=my.#
binding declared
[root@node1 ~]# rabbitmqadmin list bindings
+----------+-------------+-------------+
|  source  | destination | routing_key |
+----------+-------------+-------------+
|          | test        | test        |
| my.topic | test        | my.#        |
+----------+-------------+-------------+
</code></pre>
<p>需要注意：我们上面创建的 Binding（最后那个），就是将名称为my.topic的 Exchange 和名称为test的 Queue 关联起来，并且设置的routing_key规则为my.#。</p>
<p>下面我们发布两条消息：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin publish routing_key=my.test exchange=my.topic  payload=&quot;hello world by my.test&quot;
Message published
[root@node1 ~]# rabbitmqadmin publish routing_key=my.test.test exchange=my.topic  payload=&quot;hello world by my.test.test&quot;
Message published
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 2        |
+------+----------+
</code></pre>
<p>需要注意，发布的两条消息都指定了my.topic的 Exchange，但消息的routing_key不同，但都成功发布到test队列了，原因是my.test和my.test.test都符合my.#路由规则。</p>
<p>下面，我们对两条消息进行消费：</p>
<pre><code class="language-bash">[root@node1 ~]# rabbitmqadmin get queue=test requeue=false
+-------------+----------+---------------+------------------------+---------------+------------------+------------+-------------+
| routing_key | exchange | message_count |        payload         | payload_bytes | payload_encoding | properties | redelivered |
+-------------+----------+---------------+------------------------+---------------+------------------+------------+-------------+
| my.test     | my.topic | 1             | hello world by my.test | 22            | string           |            | False       |
+-------------+----------+---------------+------------------------+---------------+------------------+------------+-------------+
[root@node1 ~]# rabbitmqadmin get queue=test requeue=false
+--------------+----------+---------------+-----------------------------+---------------+------------------+------------+-------------+
| routing_key  | exchange | message_count |           payload           | payload_bytes | payload_encoding | properties | redelivered |
+--------------+----------+---------------+-----------------------------+---------------+------------------+------------+-------------+
| my.test.test | my.topic | 0             | hello world by my.test.test | 27            | string           |            | False       |
+--------------+----------+---------------+-----------------------------+---------------+------------------+------------+-------------+
[root@node1 ~]# rabbitmqadmin list queues
+------+----------+
| name | messages |
+------+----------+
| test | 0        |
+------+----------+
</code></pre>
<p>rabbitmqadmin 测试到这边，你应该就体会到了 RabbitMQ 的投递过程了吧，我们再对之前的投递过程完善下：</p>
<ol>
<li>声明一个 Queue，和谁都没有关系（只有名称和持久化配置）。</li>
<li>声明一个 Exchange，和谁都没有关系（只有名称和 Exchange Type 配置）。</li>
<li>声明一个 Binding，通过 source 和 destination，将 Queue 和 Exchange 关联起来，并通过 routing_key，设置发布消息的路由规则。</li>
<li>发布一个消息，需要指定一个 Exchange，以及本身的路由名称。</li>
<li>消费队列中的消息，需要指定一个 Queue。</li>
</ol>
<p>rabbitmqadmin 命令汇总：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>rabbitmqadmin list users</td>
<td>查看所有用户 User</td>
</tr>
<tr>
<td>rabbitmqadmin list users name</td>
<td>查看所有用户名 Username</td>
</tr>
<tr>
<td>rabbitmqadmin list users tags</td>
<td>查看所有用户角色</td>
</tr>
<tr>
<td>rabbitmqadmin list vhosts</td>
<td>查看所有虚拟主机</td>
</tr>
<tr>
<td>rabbitmqadmin list connections</td>
<td>查看所有连接</td>
</tr>
<tr>
<td>rabbitmqadmin list exchanges</td>
<td>查看所有路由 Exchange</td>
</tr>
<tr>
<td>rabbitmqadmin list bindings</td>
<td>查看所有路由与队列的关系绑定 Binding</td>
</tr>
<tr>
<td>rabbitmqadmin list permissions</td>
<td>查看所有角色的权限 Permission</td>
</tr>
<tr>
<td>rabbitmqadmin list channels</td>
<td>查看所有通道 Channel</td>
</tr>
<tr>
<td>rabbitmqadmin list consumers</td>
<td>查看所有消费者 Consumer</td>
</tr>
<tr>
<td>rabbitmqadmin list queues</td>
<td>查看所有消息队列 Queue</td>
</tr>
<tr>
<td>rabbitmqadmin list nodes</td>
<td>查看所有节点 Node</td>
</tr>
<tr>
<td>rabbitmqadmin show overview</td>
<td>概览 Overview</td>
</tr>
<tr>
<td>rabbitmqadmin list bindings source destination_type destination properties_key</td>
<td>查看所有路由与队列的关系绑定的详细信息 Binding</td>
</tr>
<tr>
<td>rabbitmqadmin declare queue name=test durable=true</td>
<td>定义一个队列queue，durable=true代表持久化打开。</td>
</tr>
<tr>
<td>rabbitmqadmin declare exchange name=my.fanout type=fanout</td>
<td>定义一个Fanout路由</td>
</tr>
<tr>
<td>rabbitmqadmin declare exchange name=my.direct type=direct</td>
<td>定义一个Direct路由</td>
</tr>
<tr>
<td>rabbitmqadmin declare exchange name=my.topic type=topic</td>
<td>定义一个Topic路由</td>
</tr>
<tr>
<td>rabbitmqadmin declare binding source=my.fanout destination=test routing_key=first</td>
<td>定义 binding</td>
</tr>
<tr>
<td>rabbitmqadmin publish routing_key=test payload=&quot;hello world&quot;</td>
<td>发布一条消息</td>
</tr>
<tr>
<td>rabbitmqadmin publish routing_key=my.test exchange=my.topic payload=&quot;hello world&quot;</td>
<td>使用路由转发消息</td>
</tr>
<tr>
<td>rabbitmqadmin get queue=test requeue=true</td>
<td>查看消息，不消费</td>
</tr>
<tr>
<td>rabbitmqadmin get queue=test requeue=false</td>
<td>查看消息，并消费</td>
</tr>
<tr>
<td>rabbitmqadmin purge queue name=test</td>
<td>删除队列中的所有消息</td>
</tr>
<tr>
<td>rabbitmqadmin delete queue name=hello</td>
<td>删除消息队列 Queue</td>
</tr>
<tr>
<td>rabbitmqadmin delete user name=test</td>
<td>删除用户 User</td>
</tr>
<tr>
<td>rabbitmqadmin delete exchange name=test</td>
<td>删除路由器 Exchange</td>
</tr>
<tr>
<td>rabbitmqadmin delete binding source='kk' destination_type=queue destination=test properties_key=test</td>
<td>删除路由器与消息队列的关系绑定 Binding</td>
</tr>
<tr>
<td>rabbitmqadmin -f raw_json list users	raw_json</td>
<td>格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f long list users</td>
<td>格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f pretty_json list users	pretty_json</td>
<td>格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f kvp list users</td>
<td>格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f tsv list users</td>
<td>格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f table list users</td>
<td>table 格式化输出</td>
</tr>
<tr>
<td>rabbitmqadmin -f bash list users</td>
<td>bash 格式化输出</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[部署 redis，ipfs ，ipfs-gate，mongodb， rabbitmq]]></title>
        <id>https://chriswsq.github.io/post/bu-shu-redisipfs-ipfs-gatemongodb-rabbitmq/</id>
        <link href="https://chriswsq.github.io/post/bu-shu-redisipfs-ipfs-gatemongodb-rabbitmq/">
        </link>
        <updated>2021-01-11T08:07:48.000Z</updated>
        <content type="html"><![CDATA[<p>登录ansible 节点 192.168.1.176</p>
<p>/application/ansible-playbook/optimization/{java redis mongodb rabbitmq ipfs}</p>
<p>在 /etc/ansible/inventory/   目录下添加 ipfs 的 hosts 文件<br>
执行</p>
<pre><code class="language-bash">#安装java
cd  /application/ansible-playbook/optimization/java
ansible-playbook -e host=ipfs install-java.yaml

#安装redis
cd /application/ansible-playbook/optimization/redis
ansible-playbook -e host=ipfs  docker-compose-redis.yaml

#安装ipfs
cd /application/ansible-playbook/optimization/ipfs
ansible-playbook -e host=ipfs  docker-compose-redis.yaml 
#登录ipfs服务器修改conf文件

核心属性
&quot;GCPeriod&quot;: &quot;2h&quot;,
    &quot;StorageGCWatermark&quot;: 100,
&quot;StorageMax&quot;: &quot;1GB&quot;


#安装mongodb
cd  /application/ansible-playbook/optimization/mongodb
ansible-playbook -e host=ipfs  install-mongodb.yaml

# 安装ipfs-gate
ipfs-gate由开发部署或者提供相关部署文档
登录阿里云控制台添加ipfs-gate域名A记录（域名由开发提供）
</code></pre>
<p>找提供商开启服务器业务响应端口</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mongodb基础知识与部署]]></title>
        <id>https://chriswsq.github.io/post/mongodb-ji-chu-zhi-shi-yu-bu-shu/</id>
        <link href="https://chriswsq.github.io/post/mongodb-ji-chu-zhi-shi-yu-bu-shu/">
        </link>
        <updated>2021-01-11T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>我们在安装完mongodb之后，默认是没有开启权限认证的， 但是我们在生产环境权限认证是必不可少的</p>
<h1 id="命令行部署">命令行部署</h1>
<h2 id="1-创建用户">1. 创建用户</h2>
<p>启动mongo shell<br>
我们先创建个管理员账号（该账号可以对所有数据库进行用户管理）</p>
<pre><code class="language-bash">root@2613c68bd252:/# mongo     #进入命令行
MongoDB shell version v4.2.6
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session { &quot;id&quot; : UUID(&quot;4b9dd82a-5098-41f1-a265-45bcff0ad0e3&quot;) }
MongoDB server version: 4.2.6
&gt; use admin
switched to db admin
&gt; db.createUser(
... {
...   user: &quot;admin&quot;,
...   pwd: &quot;123456&quot;,
...   roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;} ]
... }
... )
Successfully added user: {
        &quot;user&quot; : &quot;admin&quot;,
        &quot;roles&quot; : [
                {
                        &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,
                        &quot;db&quot; : &quot;admin&quot;
                }
        ]
}
</code></pre>
<h2 id="2-开启权限认证">2. 开启权限认证</h2>
<p>修改conf文件</p>
<pre><code class="language-conf">maxConns = 1000000
fork = false
port = 27017
pidfilepath = /var/run/mongodb_27017.pid
dbpath = /var/lib/mongodb/
logpath = /var/log/mongodb/mongodb.log
logappend = true
bind_ip  = 0.0.0.0
auth = true                         #启动认证模块
journal = true
</code></pre>
<p>重新启动即可</p>
<h1 id="docker部署">docker部署</h1>
<h2 id="docker-compose">docker-compose</h2>
<pre><code class="language-yml">version: '2'
services:
  mongodb:
    image: mongo
    ports:
        - 27017:27017
    volumes:
        - &quot;./data/configdb:/data/configdb&quot;
        - &quot;./data/db:/data/db&quot;
    command: mongod --auth
    environment:
      - MONGO_INITDB_ROOT_USERNAME=root       #初始化管理员用户名和密码
      - MONGO_INITDB_ROOT_PASSWORD=123456
    tty: true
</code></pre>
<h2 id="带上mongo-expressweb管理页面">带上mongo-express，web管理页面。</h2>
<pre><code class="language-yml"># Use root/example as user/password credentials
version: '3.1'

services:

  mongo:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: root
    # command: [&quot;--bind_ip_all&quot;]
    ports:
      - &quot;27017:27017&quot;

  mongo-express:
    image: mongo-express
    restart: always
    ports:
      - 8081:8081
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: root
      ME_CONFIG_MONGODB_ADMINPASSWORD: root
</code></pre>
<p>运行docker ps查看容器是否运行。</p>
<p>进入docker容器并进入mongo命令行。</p>
<pre><code class="language-bash">docker exec -it  test bash
mongo
</code></pre>
<p>此时show dbs无法执行，需要认证。<br>
切换到admin并创建root用户：</p>
<pre><code class="language-bash">use admin
db.createUser({ user: 'admin', pwd: 'admin', roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ] })
</code></pre>
<h2 id="3-创建其他的账号">3. 创建其他的账号</h2>
<pre><code class="language-bash">&gt; use admin
switched to db admin
&gt; db.auth(&quot;admin&quot;, &quot;admin&quot;)
1
&gt; db.createUser(
... {
...  user : &quot;my_tester&quot;,
...  pwd : &quot;123456&quot;,
...  roles: [ { role : &quot;readWrite&quot;, db : &quot;test&quot; }  ]
... }
... )
Successfully added user: {
        &quot;user&quot; : &quot;my_tester&quot;,
        &quot;roles&quot; : [
                {
                        &quot;role&quot; : &quot;readWrite&quot;,
                        &quot;db&quot; : &quot;test&quot;
                }
        ]
}
</code></pre>
<h2 id="权限说明基于角色的权限控制">权限说明（基于角色的权限控制）</h2>
<h3 id="数据库用户角色">数据库用户角色</h3>
<p>read: 只读数据权限<br>
readWrite:学些数据权限<br>
<strong>数据库管理角色</strong></p>
<ul>
<li>dbAdmin: 在当前db中执行管理操作的权限</li>
<li>dbOwner: 在当前db中执行任意操作</li>
<li>userADmin: 在当前db中管理user的权限<br>
<strong>备份和还原角色</strong></li>
<li>backup</li>
<li>restore<br>
<strong>夸库角色</strong></li>
<li>readAnyDatabase: 在所有数据库上都有读取数据的权限</li>
<li>readWriteAnyDatabase: 在所有数据库上都有读写数据的权限</li>
<li>userAdminAnyDatabase: 在所有数据库上都有管理user的权限</li>
<li>dbAdminAnyDatabase: 管理所有数据库的权限<br>
<strong>集群管理</strong></li>
<li>clusterAdmin: 管理机器的最高权限</li>
<li>clusterManager: 管理和监控集群的权限</li>
<li>clusterMonitor: 监控集群的权限</li>
<li>hostManager: 管理Server<br>
<strong>超级权限</strong></li>
<li>root: 超级用户</li>
</ul>
<h3 id="52-自定义角色">5.2 自定义角色</h3>
<p>内置角色只能控制User在DB级别上执行的操作，管理员可以创建自定义角色，控制用户在集合级别（Collection-Level）上执行的操作，即，控制User在当前DB的特定集合上执行特定的操作</p>
<h2 id="基本命令">基本命令</h2>
<p><strong>查看创建的用户</strong></p>
<pre><code class="language-bash">show users 或 db.system.users.find() 或 db.runCommand({usersInfo:&quot;userName&quot;})
</code></pre>
<p><strong>修改密码</strong></p>
<pre><code class="language-bash">use admin
db.changeUserPassword(&quot;username&quot;, &quot;xxx&quot;)
</code></pre>
<p><strong>修改密码和用户信息</strong></p>
<pre><code class="language-bash">db.runCommand(
    {
        updateUser:&quot;username&quot;,
        pwd:&quot;xxx&quot;,
        customData:{title:&quot;xxx&quot;}
    }
)
</code></pre>
<p><strong>删除数据库用户</strong></p>
<pre><code class="language-bash">use admin
db.dropUser('user001')
</code></pre>
<p><strong>创建其他数据管理员</strong></p>
<pre><code class="language-bash">// 登录管理员用户
use admin
db.auth('admin','admin')
// 切换至db001数据库
use db001
// ... 増查改删该数据库专有用户
</code></pre>
<h2 id="重要的一步">重要的一步</h2>
<p>启用权限验证(别TM的武装了大半天，大门还一直开着，还抱怨我方防御塔怎么一直被摧毁)</p>
<pre><code class="language-bash">mongo --auth
</code></pre>
<p>或者修改mongo.conf，最后一行添加</p>
<pre><code class="language-bash">#启用权限访问
auth=true
</code></pre>
<p>参考自：https://www.jianshu.com/p/62736bff7e2e</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell脚本输出带颜色字体]]></title>
        <id>https://chriswsq.github.io/post/shell-jiao-ben-shu-chu-dai-yan-se-zi-ti/</id>
        <link href="https://chriswsq.github.io/post/shell-jiao-ben-shu-chu-dai-yan-se-zi-ti/">
        </link>
        <updated>2020-12-30T09:45:10.000Z</updated>
        <content type="html"><![CDATA[<p>输出特效格式控制：<br>
\033[0m  关闭所有属性<br>
\033[1m   设置高亮度<br>
\03[4m   下划线<br>
\033[5m   闪烁<br>
\033[7m   反显<br>
\033[8m   消隐<br>
\033[30m   --   \033[37m   设置前景色<br>
\033[40m   --   \033[47m   设置背景色</p>
<p>光标位置等的格式控制：<br>
\033[nA  光标上移n行<br>
\03[nB   光标下移n行<br>
\033[nC   光标右移n行<br>
\033[nD   光标左移n行<br>
\033[y;xH设置光标位置<br>
\033[2J   清屏<br>
\033[K   清除从光标到行尾的内容<br>
\033[s   保存光标位置<br>
\033[u   恢复光标位置<br>
\033[?25l   隐藏光标</p>
<p>\33[?25h   显示光标</p>
<p>整理：<br>
编码 颜色/动作<br>
　　0   重新设置属性到缺省设置<br>
　　1   设置粗体<br>
　　2   设置一半亮度(模拟彩色显示器的颜色)<br>
　　4   设置下划线(模拟彩色显示器的颜色)<br>
　　5   设置闪烁<br>
　　7   设置反向图象<br>
　　22 设置一般密度<br>
　　24 关闭下划线<br>
　　25 关闭闪烁<br>
　　27 关闭反向图象<br>
　　30 设置黑色前景<br>
　　31 设置红色前景<br>
　　32 设置绿色前景<br>
　　33 设置棕色前景<br>
　　34 设置蓝色前景<br>
　　35 设置紫色前景<br>
　　36 设置青色前景<br>
　　37 设置白色前景<br>
　　38 在缺省的前景颜色上设置下划线<br>
　　39 在缺省的前景颜色上关闭下划线<br>
　　40 设置黑色背景<br>
　　41 设置红色背景<br>
　　42 设置绿色背景<br>
　　43 设置棕色背景<br>
　　44 设置蓝色背景<br>
　　45 设置紫色背景<br>
　　46 设置青色背景<br>
　　47 设置白色背景<br>
　　49 设置缺省黑色背景<br>
特效可以叠加，需要使用“;”隔开，例如：闪烁+下划线+白底色+黑字为   \033[5;4;47;30m闪烁+下划线+白底色+黑字为\033[0m<br>
下面是一段小例子</p>
<p>[plain] view plain copy<br>
#!/bin/bash</p>
<h1 id=""></h1>
<p>#下面是字体输出颜色及终端格式控制<br>
#字体色范围：30-37<br>
echo -e &quot;\033[30m 黑色字 \033[0m&quot;<br>
echo -e &quot;\033[31m 红色字 \033[0m&quot;<br>
echo -e &quot;\033[32m 绿色字 \033[0m&quot;<br>
echo -e &quot;\033[33m 黄色字 \033[0m&quot;<br>
echo -e &quot;\033[34m 蓝色字 \033[0m&quot;<br>
echo -e &quot;\033[35m 紫色字 \033[0m&quot;<br>
echo -e &quot;\033[36m 天蓝字 \033[0m&quot;<br>
echo -e &quot;\033[37m 白色字 \033[0m&quot;<br>
#字背景颜色范围：40-47<br>
echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;<br>
echo -e &quot;\033[41;30m 红底黑字 \033[0m&quot;<br>
echo -e &quot;\033[42;34m 绿底蓝字 \033[0m&quot;<br>
echo -e &quot;\033[43;34m 黄底蓝字 \033[0m&quot;<br>
echo -e &quot;\033[44;30m 蓝底黑字 \033[0m&quot;<br>
echo -e &quot;\033[45;30m 紫底黑字 \033[0m&quot;<br>
echo -e &quot;\033[46;30m 天蓝底黑字 \033[0m&quot;<br>
echo -e &quot;\033[47;34m 白底蓝字 \033[0m&quot;</p>
<p>#控制选项说明<br>
#\033[0m 关闭所有属性<br>
#\033[1m 设置高亮度<br>
#\033[4m 下划线<br>
echo -e &quot;\033[4;31m 下划线红字 \033[0m&quot;<br>
#闪烁<br>
echo -e &quot;\033[5;34m 红字在闪烁 \033[0m&quot;<br>
#反影<br>
echo -e &quot;\033[8m 消隐 \033[0m &quot;</p>
<p>#\033[30m-\033[37m 设置前景色<br>
#\033[40m-\033[47m 设置背景色<br>
#\033[nA光标上移n行<br>
#\033[nB光标下移n行<br>
echo -e &quot;\033[4A 光标上移4行 \033[0m&quot;<br>
#\033[nC光标右移n行<br>
#\033[nD光标左移n行<br>
#\033[y;xH设置光标位置<br>
#\033[2J清屏<br>
#\033[K清除从光标到行尾的内容<br>
echo -e &quot;\033[K 清除光标到行尾的内容 \033[0m&quot;<br>
#\033[s 保存光标位置<br>
#\033[u 恢复光标位置<br>
#\033[?25| 隐藏光标<br>
#\033[?25h 显示光标<br>
echo -e &quot;\033[?25l 隐藏光标 \033[0m&quot;<br>
echo -e &quot;\033[?25h 显示光标 \033[0m&quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cita链管理升级步骤]]></title>
        <id>https://chriswsq.github.io/post/cita-lian-guan-li-sheng-ji-bu-zou/</id>
        <link href="https://chriswsq.github.io/post/cita-lian-guan-li-sheng-ji-bu-zou/">
        </link>
        <updated>2020-12-30T09:21:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="链管理升级步骤">链管理升级步骤：</h1>
<ol>
<li>
<h3 id="停止链管理服务">停⽌链管理服务</h3>
</li>
</ol>
<pre><code>kill $(cat /bsn/cita-manager/bsn-cita-chain-manager-v0.1/gunicorn.pid) 
</code></pre>
<ol start="2">
<li>
<h3 id="备份程序文件">备份程序文件</h3>
</li>
</ol>
<pre><code class="language-bash">cp -rf /bsn/cita-manager/bsn-cita-chain-manager-v0.1 /bsn/cita-manager/bsn-cita-chain-manager-v0.1.20201229
</code></pre>
<ol start="3">
<li>
<h3 id="解压新代码包并将文件拷至老目录">解压新代码包并将⽂件拷⻉⾄⽼⽬录</h3>
</li>
</ol>
<pre><code class="language-shell">tar xzvf bsn-cita-chain-manager-develop.tar.gz

yes | cp -rf bsn-cita-chain-manager-develop/.   /bsn/cita-manager/bsn-cita-chain-manager-v0.1
</code></pre>
<ol start="3">
<li>修改数据库密码</li>
</ol>
<pre><code class="language-bash"> cd  /bsn/cita-manager/bsn-cita-chain-manager-v0.1
 修改cita.db中的表node  字段pwd
 
xxxxxxxx

加密后的字符串为:

xxxxxxxxxxxxxxxxxxx
</code></pre>
<ol start="3">
<li>
<h3 id="进入原链管理服务目录执行升级命令">进⼊原链管理服务⽬录，执⾏升级命令</h3>
</li>
</ol>
<pre><code class="language-shell"> cd /bsn/cita-manager/bsn-cita-chain-manager-v0.1

 rm -rf logs 

 make update 
</code></pre>
<ol start="4">
<li>
<h3 id="将原来产生的链配置复制到链管理服务目录">将原来产⽣的链配置复制到链管理服务⽬录</h3>
</li>
</ol>
<pre><code class="language-shell">mkdir chain-config 

cp -rf /opt/all-chain-config/. /bsn/cita-manager/bsn-cita-chain-manager-v0.1/chain-config/ 

make start 
</code></pre>
<p>节点管理升级步骤：</p>
<ol>
<li>运行数据库脚本：   dml20201118/ddl.sql    dml20201118/dml.sql</li>
<li>运行数据库脚本：  update tb_cita_nodeinfo set status=1;   先执行ddl  再执行dml</li>
<li>重新部署war包</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[aws-- Amazon  API  Gateway功能]]></title>
        <id>https://chriswsq.github.io/post/aws-amazon-api-gateway-gong-neng/</id>
        <link href="https://chriswsq.github.io/post/aws-amazon-api-gateway-gong-neng/">
        </link>
        <updated>2020-12-24T08:51:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="支持的api">支持的API</h2>
<p>RESTful API、WebSocket API、HTTP API 和 REST API 私有 （只能从vpc访问的REST API）</p>
<h2 id="特点">特点</h2>
<p><strong>规则限流</strong><br>
为API中每个HTTP方法设置限制规则，管理指向后端系统的流量</p>
<p><strong>监控</strong><br>
API调用次数，延迟和错误率，设置自定义报警</p>
<p><strong>授权</strong><br>
身份认证，连接管理，访问策略，lambda函数验证持有者令牌，（jwt令牌或saml断言）</p>
<p><strong>秘钥</strong><br>
REST API 可在gateway上创建API 秘钥，并设置权限，将其分发给第三方开发人员以访问API</p>
<p><strong>生成开发工具包</strong><br>
REST API 可以为大量平台生成客户端开发工具包，测试新API，分发给第三方开发人员。API Gateway 可以生成适用于 Java、JavaScript、Java for Android、Objective-C 或 Swift for iOS 和 Ruby 的客户端开发工具包。可以使用 AWS CLI，通过调用 get-sdk 命令为支持的平台生成 API 的开发工具包并下载。</p>
<p><strong>API 生命周期管理</strong><br>
REST API，API Gateway 使您可以同时运行同一 API 的多个版本，管理每个 API 版本的多个发布阶段</p>
<p><strong>功能</strong><br>
<strong>REST API</strong><br>
API网关提供了REST API管理功能，例如：<br>
支持使用OpenAPI的API网关扩展来生成SDK和创建API文档<br>
限制HTTP请求<br>
<strong>WebSocket API</strong><br>
API网关提供WebSocket API管理功能，例如：<br>
监视和限制连接和消息<br>
使用AWS X-Ray跟踪通过API传递到后端服务的消息<br>
轻松与HTTP / HTTPS端点集成</p>
<p>rest api<br>
客户端证书，秘钥</p>
<p>websocke  api<br>
客户端证书</p>
<p>http  api<br>
限制（路由限制和突增限制）   能监控  日志</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quorum、tessera、cakeshop服务基本知识]]></title>
        <id>https://chriswsq.github.io/post/quorumtesseracakeshop-fu-wu-ji-ben-zhi-shi/</id>
        <link href="https://chriswsq.github.io/post/quorumtesseracakeshop-fu-wu-ji-ben-zhi-shi/">
        </link>
        <updated>2020-12-14T08:10:18.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>quorum分别有两个共识<br>
raft、bft</p>
</li>
<li>
<p>quorum依赖环境<br>
go</p>
</li>
<li>
<p>quorum节点分类<br>
bft共识分为：验证节点和非验证节点。验证节点可以作为主节点的备份，非验证节点只同步数据</p>
</li>
<li>
<p>tessera为私人交易管理器<br>
通常的方式创建为彼岸准的以太坊交易，私有交易不会按标准的以太坊执行：在发送方的GoQuorum节点将交易传播到网络的其余部分之前，它将原始交易有效载荷替换为从Constellation / Tessera接收到的加密有效载荷的哈希值。参与交易的参与者将能够通过其Constellation / Tessera实例将哈希值替换为实际有效载荷，而未参与交易的参与者将只能看到哈希值。</p>
</li>
<li>
<p>quorum创始块文件为genesis.json</p>
</li>
<li>
<p>quorum集群连接信息配置在static-nodes.json文件</p>
</li>
<li>
<p>tessera的配置文件为tessera-config.json</p>
</li>
<li>
<p>Cakeshop 为quorum服务的web管理器</p>
</li>
<li>
<p>cakeshop的配置文件为application.properties</p>
</li>
<li>
<p>cakeshop连接quorum节点连接信息的文件为nodes.json</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker-compose启动quorum、tessera、cakeshop--raft共识]]></title>
        <id>https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/</id>
        <link href="https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/">
        </link>
        <updated>2020-12-14T07:09:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker-compose文件">docker-compose文件</h2>
<pre><code class="language-yml">version: &quot;3.6&quot;
x-quorum-def:
  &amp;quorum-def
  restart: &quot;on-failure&quot;
  image: quorumengineering/quorum:20.10.0
  expose:
    - &quot;21000&quot;
    - &quot;50000&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy&quot;, &quot;off&quot;, &quot;http://localhost:22000&quot;]
    interval: 3s
    timeout: 3s
    retries: 10
    start_period: 5s
  labels:
    com.quorum.consensus: raft
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/dd
      cat $${DDIR}/static-nodes.json
      GENESIS_FILE=&quot;$${DDIR}/genesis.json&quot;
      NETWORK_ID=$$(cat $${GENESIS_FILE} | grep chainId | awk -F &quot; &quot; '{print $$2}' | awk -F &quot;,&quot; '{print $$1}')
      geth --datadir $${DDIR} init $${GENESIS_FILE}
      geth \
        --identity node1-raft \
        --datadir $${DDIR} \
        --permissioned \
        --nodiscover \
        --verbosity 5 \
        --networkid $${NETWORK_ID} \
        --rpc \
        --raft \
        --raftport 50000 \
        --rpcaddr 0.0.0.0 \
        --rpcport 22000 \
        --rpcapi admin,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \
        --port 21000 \
        --unlock 0 \
        --allow-insecure-unlock \
        --nousb \
        --password $${DDIR}/passwords.txt \
x-tx-manager-def:
  &amp;tx-manager-def
  image: quorumengineering/tessera:20.10.0
  expose:
    - &quot;9000&quot;
    - &quot;9080&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD-SHELL&quot;, &quot;[ -S /qdata/tm/tm.ipc ] || exit 1&quot;]
    interval: 3s
    timeout: 3s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      if [ &quot;$${PRIVATE_CONFIG}&quot; == &quot;ignore&quot; ]; then
        /bin/true
        exit 0
      fi
      DDIR=/qdata/tm
      mkdir -p $${DDIR}
          #extract the tessera version from the jar
          TESSERA_VERSION=$$(unzip -p /tessera/tessera-app.jar META-INF/MANIFEST.MF | grep Tessera-Version | cut -d&quot; &quot; -f2)
          #generating the two config flavors
          cat &lt;&lt;EOF &gt; $${DDIR}/tessera-config.json
          {
            &quot;useWhiteList&quot;: false,
            &quot;jdbc&quot;: {
              &quot;username&quot;: &quot;sa&quot;,
              &quot;password&quot;: &quot;&quot;,
              &quot;url&quot;: &quot;jdbc:h2:./$${DDIR}/db;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
              &quot;autoCreateTables&quot;: true
            },
            &quot;serverConfigs&quot;:[
            {
              &quot;app&quot;:&quot;ThirdParty&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9080&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;Q2T&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;unix:$${DDIR}/tm.ipc&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;P2P&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9000&quot;,
              &quot;sslConfig&quot;: {
                &quot;tls&quot;: &quot;OFF&quot;
              },
              &quot;communicationType&quot; : &quot;REST&quot;
            }
            ],
            &quot;peer&quot;: [
               {
                   &quot;url&quot;: &quot;http://192.168.40.6:9000&quot;
               },
               {
                   &quot;url&quot;: &quot;http://192.168.40.7:9000&quot;
               }
            ],
            &quot;keys&quot;: {
              &quot;passwords&quot;: [],
              &quot;keyData&quot;: [
                {
                  &quot;config&quot;: $$(cat $${DDIR}/tm.key),
                  &quot;publicKey&quot;: &quot;$$(cat $${DDIR}/tm.pub)&quot;
                }
              ]
            },
            &quot;alwaysSendTo&quot;: []
          }
      EOF
          cat $${DDIR}/tessera-config.json
          java -Xms128M -Xmx128M -jar /tessera/tessera-app.jar -configfile $${DDIR}/tessera-config.json
x-cakeshop-def:
  &amp;cakeshop-def
  image: &quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
  expose:
    - &quot;8999&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy=off&quot;, &quot;http://localhost:8999/actuator/health&quot;]
    interval: 5s
    timeout: 5s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/cakeshop/local
      mkdir -p $${DDIR}
      DOCKER_IMAGE=&quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
      java -Xms128M -Xmx128M -Dcakeshop.config.dir=/qdata/cakeshop -Dlogging.path=/qdata/logs/cakeshop -jar /opt/cakeshop/cakeshop.war
      ;;
services:
  node1:
    &lt;&lt; : *quorum-def
    hostname: node1
    ports:
      - &quot;22000:22000&quot;
      - &quot;21000:21000&quot;
      - &quot;50000:50000&quot;
    volumes:
      - ./data:/qdata
    depends_on:
      - txmanager1
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.11
  txmanager1:
    &lt;&lt; : *tx-manager-def
    hostname: txmanager1
    ports:
      - &quot;9080:9080&quot;
    volumes:
      - ./data:/qdata
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.101
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}

  cakeshop:
    &lt;&lt; : *cakeshop-def
    hostname: cakeshop
    ports:
      - &quot;8999:8999&quot;
    volumes:
      - ./data:/qdata

networks:
  quorum-examples-net:
    name: quorum-examples-net
    driver: bridge
    ipam:
      driver: default
      config:
      - subnet: 172.16.239.0/24
</code></pre>
<h2 id="挂载所需文件及目录">挂载所需文件及目录</h2>
<p>当前目录为 /bsn/quorum</p>
<p>data<br>
|---  cakeshop<br>
|-------|-- local<br>
|------------|-- application.properties<br>
|------------|-- nodes.json<br>
|<br>
| --- dd<br>
|------|-- genesis.json<br>
|------|-- keystore<br>
|------|------|-- key<br>
|------|-- passwords.txt<br>
|------|--  permissioned-nodes.json<br>
|------|-- static-nodes.json<br>
|------|-- disallowed-nodes.json<br>
|<br>
|---- tm<br>
------|-- tessera-config.json</p>
<h3 id="cakeshop-挂载文件">cakeshop 挂载文件</h3>
<p><strong>application.properties文件为cakeshop的配置文件，配置服务端口，链接文件，安全配置等</strong></p>
<pre><code class="language-yml">#Mon Dec 14 07:18:51 UTC 2020
spring.main.banner-mode=off
security.ignored=/**
geth.log=/logs
spring.mvc.view.suffix=.jsp
geth.auto.stop=false
geth.identity=bradmcdermott
geth.cors.url=
endpoints.actuator.enabled=true
security.basic.enabled=false
nodejs.binary=node
contract.poll.delay.millis=5000
geth.mining=true
cakeshop.initialnodes=qdata/cakeshop/local/nodes.json
geth.node.port=30303
geth.cors.enabled=false
management.security.enabled=false
server.port=8999
geth.release.url=
server.compression.enabled=true
geth.url=http\://localhost\:8102
geth.vote.contract.addr=0x0000000000000000000000000000000000000020
cakeshop.hibernate.jdbc.batch_size=20
cakeshop.database.vendor=hsqldb
geth.consensus.mode=raft
geth.tools.url=
cakeshop.mvc.async.pool.threads.max=1000
cakeshop.jdbc.user=sdk
geth.transaction_manager.url=http\://localhost\:9102
spring.mvc.view.prefix=/WEB-INF/jsp/
geth.verbosity=
geth.auto.start=false
cakeshop.hibernate.hbm2ddl.auto=update
cakeshop.selected_node=1
geth.raft.network.id=
geth.istanbul.url=
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain
geth.bootnode.address=
cakeshop.mvc.async.pool.queue.max=2000
cakeshop.mvc.async.pool.threads.core=250
management.context-path=/manage
geth.db.enabled=true
geth.cred1=admin
geth.datadir=/qdata/cakeshop/local/ethereum
geth.raft.port=22000
geth.cred2=$2a$10$dbGiTnfK/w8MhcpIj3XgROYXRsFMlEYJRWoUYArkr8aSPypUFV25G
geth.params.extra=
geth.raft.blocktime=100
geth.bootnodes.list=
geth.networkid=1006
geth.bootnode.key=
geth.startup.mode=standalone
cakeshop.jdbc.pass=sdk
geth.transaction_manager.peers=http\://localhost\:9102
geth.rpcapi.list=admin,db,eth,debug,miner,net,shh,txpool,personal,web3
log4j.rootLogger=DEBUG, stdout
contract.registry.addr=
geth.unlock.timeout=5000
</code></pre>
<p><strong>nodes.json 文件配置连接quorum服务节点的地址(也可可续在web页面添加)</strong></p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;node1&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.6:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.6:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node2&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.7:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.7:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node3&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.8:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.8:9080&quot;
  }
]
</code></pre>
<h3 id="quorum挂载文件">quorum挂载文件</h3>
<ul>
<li>disallowed-nodes.json：禁止访问定义</li>
<li>keysstore/key：创建用户的账号key存储</li>
<li>genesis.json：创世块文件</li>
<li>passwords.txt：解锁密钥存储</li>
<li>permissioned-nodes.json：允许访问定义列表</li>
<li>static-nodes.json：集群节点连接信息</li>
</ul>
<p><strong>disallowed-nodes.json</strong></p>
<pre><code class="language-bash">[
]
</code></pre>
<p><strong>keysstore/key</strong><br>
账户文件通过命令提前生成<br>
生成的key名字可以更改，密码最好设置为空</p>
<pre><code class="language-bash">geth --datadir dd account new
ll data/dd/keystore/
UTC--2020-12-07T03-33-12.115191344Z--93f0b48f9d921f38dabff36cb682bfb208472221
</code></pre>
<p><strong>genesis.json</strong></p>
<p>文件内的alloc参数根据创建的账户文件生成的key来填写</p>
<pre><code class="language-json">{
  &quot;alloc&quot;: {
    &quot;0xCcfaC6Cfb21D1f10C915d0e4189586765c30089e&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    },
    &quot;0x1ff1a9c504703b8e623640be516e768f3d175d14&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    }
  },
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;config&quot;: {
    &quot;homesteadBlock&quot;: 0,
    &quot;byzantiumBlock&quot;: 0,
    &quot;constantinopleBlock&quot;: 0,
    &quot;petersburgBlock&quot;: 0,
    &quot;istanbulBlock&quot;: 0,
    &quot;chainId&quot;: 10,
    &quot;eip150Block&quot;: 0,
    &quot;eip155Block&quot;: 0,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip158Block&quot;: 0,
    &quot;isQuorum&quot;: true,
    &quot;maxCodeSizeConfig&quot; : [
      {
        &quot;block&quot; : 0,
        &quot;size&quot; : 32
      }
    ]
  },
  &quot;difficulty&quot;: &quot;0x0&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0xE0000000&quot;,
  &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;timestamp&quot;: &quot;0x00&quot;
}
</code></pre>
<p><strong>passwords.txt</strong><br>
最好为空，不然会与在页面创建的用户有冲突</p>
<pre><code class="language-bash">test
</code></pre>
<p><strong>permissioned-nodes.json</strong><br>
文件中的id使用命令提前生成</p>
<pre><code class="language-bash"> bootnode --genkey=nodekey
 cp nodekey 
 bootnode --nodekey=nodekey --writeaddress
</code></pre>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<p><strong>static-nodes.json</strong></p>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoQuorum之raft共识添加添加隐私交易管理器tessera--二进制]]></title>
        <id>https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/</id>
        <link href="https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/">
        </link>
        <updated>2020-12-07T07:37:57.000Z</updated>
        <content type="html"><![CDATA[<p>tessera</p>
<p>公共与私人交易处理<br>
公共交易是以标准的以太坊方式执行的，因此，如果将公共交易发送到持有合同代码的账户，则每个参与者将执行相同的代码，并且其底层StateDB将相应地更新。</p>
<p>但是，私有交易不会按标准的以太坊执行：在发送方的GoQuorum节点将交易传播到网络的其余部分之前，它将原始交易有效载荷替换为从Constellation / Tessera接收到的加密有效载荷的哈希值。参与交易的参与者将能够通过其Constellation / Tessera实例将哈希值替换为实际有效载荷，而未参与交易的参与者将只能看到哈希值。</p>
<p>结果是，如果将私人交易发送到持有合同代码的帐户，则那些不参与交易的参与者将最终跳过交易，因此不执行合同代码。但是，参与交易的那些参与者将在调用EVM执行之前将哈希替换为原始有效负载，并且其StateDB将相应地更新。如果没有对geth客户进行相应的更改，那么这两组参与者最终将拥有不同的StateDB，并且无法达成共识。为了支持合同状态的这种分叉，Quorum将公共合同的状态存储在全局同步的Public State Trie中，</p>
<h2 id="安装goquorum和tessera">安装GoQuorum和tessera</h2>
<pre><code class="language-bash">$ git clone https://github.com/ConsenSys/quorum.git
$ cd quorum
$ make all
$ export PATH=$(pwd)/build/bin:$PATH
$ cd ..
.... copy tessera jar to your desired destination and rename it as tessera
$ mv tessera-app-20.10.0-app.jar tessera.jar
</code></pre>
<h2 id="生成新密钥">生成新密钥</h2>
<pre><code class="language-bash">$ mkdir new-node-1t
$ cd new-node-1t
$ java -jar ../tessera.jar -keygen -filename new-node-1
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:32:51.256 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:32:51.279 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[pnesVeDgs805ZPbnulzC5wokDzpdN7CeYKVUBXup/W4=] and private key REDACTED
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-1t/new-node-1.pub
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-1t/new-node-1.key
</code></pre>
<h2 id="创建configjson配置文件">创建config.json配置文件</h2>
<pre><code class="language-bash">{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-1t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.6:9081&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-1t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.6:9001&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动其他节点">启动其他节点</h2>
<p>如果要启动另一个Tessera节点，请重复步骤2和步骤3</p>
<pre><code class="language-bash">$ cd ..
$ mkdir new-node-2t
$ cd new-node-2t
$ java -jar ../tessera.jar -keygen -filename new-node-2
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:45:02.567 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:45:02.585 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[AeggpVlVsi+rxD6h9tcq/8qL/MsjyipUnkj1nvNPgTU=] and private key REDACTED
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-2t/new-node-2.pub
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-2t/new-node-2.key
$
$ vim config.json

{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-2t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.7:9082&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-2t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.7:9002&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动tessera节点">启动tessera节点</h2>
<p>启动您的Tessera节点，然后发送到后台<br>
分别在192.168.40.6   192.168.40.7执行</p>
<pre><code class="language-bash">java -jar ../tessera.jar -configfile config.json &gt;&gt; tessera.log 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="修改goquorum启动脚本">修改GoQuorum启动脚本</h2>
<p>从上方启动连接到正在运行的Tessera节点的GoQuorum节点并将其发送到后台</p>
<p>192.168.40.6</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-1t/tm.ipc nohup geth --allow-insecure-unlock  --datadir new-node-1 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<p>192.168.40.7</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-2t/tm.ipc nohup geth --allow-insecure-unlock --datadir new-node-2 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<blockquote>
<p>注意：<br>
Tessera IPC桥接器将位于您定义的文件名上config.json，通常以tm.ipc前缀中的名称命名PRIVATE_CONFIG=tm.ipc。您的节点现在可以发送和接收私人交易，播发的公共节点密钥将在new-node-1.pub文件中。Tessera提供了很多配置灵活性，有关完整和最新的配置选项，请参阅Tessera下的“配置”部分。<br>
--allow-insecure-unlock  用于解锁用户</p>
</blockquote>
<h2 id="发送私人交易">发送私人交易</h2>
<p>您的节点现在可以运行了，您可以附加到该节点geth attach new-node-1/geth.ipc以发送私人交易。</p>
<pre><code class="language-bash">$ vim private-contract.js
... create simple private contract to send transaction from new-node-1 private for new-node-2's tessera public key created in step 4
a = eth.accounts[0]
web3.eth.defaultAccount = a;

// abi and bytecode generated from simplestorage.sol:
// &gt; solcjs --bin --abi simplestorage.sol
var abi = [{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;storedData&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;x&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;set&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;get&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;retVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;name&quot;:&quot;initVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;constructor&quot;}];

var bytecode = &quot;0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029&quot;;

var simpleContract = web3.eth.contract(abi);
var simple = simpleContract.new(42, {from:web3.eth.accounts[0], data: bytecode, gas: 0x47b760, privateFor: [&quot;R5qs4JXQ+aiJqh2V98qgbPZj+rR82ZodCq2CAUyIJjw=&quot;]}, function(e, contract) {
    if (e) {
        console.log(&quot;err creating contract&quot;, e);
    } else {
        if (!contract.address) {
            console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;);
        } else {
            console.log(&quot;Contract mined! Address: &quot; + contract.address);
            console.log(contract);
        }
    }
});
$
$
</code></pre>
<blockquote>
<p>注意： 默认情况下，在geth中打开的帐户是锁定的，因此在发送交易之前，请先解锁帐户，所以启动需要加上--allow-insecure-unlock参数，不然解锁用户时会报错Error: account unlock with HTTP access is forbidden</p>
</blockquote>
<pre><code class="language-bash">
[root@test-1 fromscratch]# geth attach new-node-1/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.9.7-stable-7b726385(quorum-v20.10.0)/linux-amd64/go1.15.1
coinbase: 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
at block: 0 (Thu, 01 Jan 1970 08:00:00 CST)
 datadir: /bsn/quorum/fromscratch/new-node-1
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 quorumExtension:1.0 raft:1.0 rpc:1.0 txpool:1.0 web3:1.0

&gt; eth.accounts
[&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;, &quot;0x93f0b48f9d921f38dabff36cb682bfb208472221&quot;]
&gt; personal.unlockAccount(&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;);
Unlock account 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
Password: 
true
&gt; loadScript(&quot;private-contract.js&quot;)
Contract transaction send: TransactionHash: 0xfaf11707339302bc62bfbfe6968ea20e5b511fc1450f799a5ac95a91a512c8fa waiting to be mined...
true
&gt; Contract mined! Address: 0xb85f26e18472df8c33633990b8ba8eb7d012966c
[object Object]

</code></pre>
<p>您已成功将私有事务从节点1发送到节点2！</p>
<blockquote>
<p>注意：如果private-contract.js中的数组中没有有效的公共密钥，则在加载脚本时会看到以下错误。</p>
</blockquote>
<pre><code class="language-bash">&gt; loadScript(&quot;private-contract.js&quot;)
err creating contract Error: Non-200 status code: &amp;{Status:400 Bad Request StatusCode:400 Proto:HTTP/1.1 ProtoMajor:1      ProtoMinor:1 Header:map[Date:[Mon, 17 Jun 2019 15:23:53 GMT] Content-Type:[text/plain] Content-Length:[73] Server:[Jetty(9.4.z-SNAPSHOT)]] Body:0xc01997a580 ContentLength:73 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc019788200 TLS:&lt;nil&gt;}
</code></pre>
]]></content>
    </entry>
</feed>