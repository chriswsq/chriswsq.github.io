<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chriswsq.github.io</id>
    <title>chris&apos;wang</title>
    <updated>2021-01-11T08:33:52.596Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chriswsq.github.io"/>
    <link rel="self" href="https://chriswsq.github.io/atom.xml"/>
    <subtitle>当你觉得无所事事时，那你就是在虚度光阴</subtitle>
    <logo>https://chriswsq.github.io/images/avatar.png</logo>
    <icon>https://chriswsq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, chris&apos;wang</rights>
    <entry>
        <title type="html"><![CDATA[部署 redis，ipfs ，ipfs-gate，mongodb， rabbitmq]]></title>
        <id>https://chriswsq.github.io/post/bu-shu-redisipfs-ipfs-gatemongodb-rabbitmq/</id>
        <link href="https://chriswsq.github.io/post/bu-shu-redisipfs-ipfs-gatemongodb-rabbitmq/">
        </link>
        <updated>2021-01-11T08:07:48.000Z</updated>
        <content type="html"><![CDATA[<p>登录ansible 节点 192.168.1.176</p>
<p>/application/ansible-playbook/optimization/{java redis mongodb rabbitmq ipfs}</p>
<p>在 /etc/ansible/inventory/   目录下添加 ipfs 的 hosts 文件<br>
执行</p>
<pre><code class="language-bash">#安装java
cd  /application/ansible-playbook/optimization/java
ansible-playbook -e host=ipfs install-java.yaml

#安装redis
cd /application/ansible-playbook/optimization/redis
ansible-playbook -e host=ipfs  docker-compose-redis.yaml

#安装ipfs
cd /application/ansible-playbook/optimization/ipfs
ansible-playbook -e host=ipfs  docker-compose-redis.yaml 
#登录ipfs服务器修改conf文件

核心属性
&quot;GCPeriod&quot;: &quot;2h&quot;,
    &quot;StorageGCWatermark&quot;: 100,
&quot;StorageMax&quot;: &quot;1GB&quot;


#安装mongodb
cd  /application/ansible-playbook/optimization/mongodb
ansible-playbook -e host=ipfs  install-mongodb.yaml

# 安装ipfs-gate
ipfs-gate由开发部署或者提供相关部署文档
登录阿里云控制台添加ipfs-gate域名A记录（域名由开发提供）
</code></pre>
<p>找提供商开启服务器业务响应端口</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mongodb基础知识与部署]]></title>
        <id>https://chriswsq.github.io/post/mongodb-ji-chu-zhi-shi-yu-bu-shu/</id>
        <link href="https://chriswsq.github.io/post/mongodb-ji-chu-zhi-shi-yu-bu-shu/">
        </link>
        <updated>2021-01-11T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>我们在安装完mongodb之后，默认是没有开启权限认证的， 但是我们在生产环境权限认证是必不可少的</p>
<h1 id="命令行部署">命令行部署</h1>
<h2 id="1-创建用户">1. 创建用户</h2>
<p>启动mongo shell<br>
我们先创建个管理员账号（该账号可以对所有数据库进行用户管理）</p>
<pre><code class="language-bash">root@2613c68bd252:/# mongo     #进入命令行
MongoDB shell version v4.2.6
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session { &quot;id&quot; : UUID(&quot;4b9dd82a-5098-41f1-a265-45bcff0ad0e3&quot;) }
MongoDB server version: 4.2.6
&gt; use admin
switched to db admin
&gt; db.createUser(
... {
...   user: &quot;admin&quot;,
...   pwd: &quot;123456&quot;,
...   roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;} ]
... }
... )
Successfully added user: {
        &quot;user&quot; : &quot;admin&quot;,
        &quot;roles&quot; : [
                {
                        &quot;role&quot; : &quot;userAdminAnyDatabase&quot;,
                        &quot;db&quot; : &quot;admin&quot;
                }
        ]
}
</code></pre>
<h2 id="2-开启权限认证">2. 开启权限认证</h2>
<p>修改conf文件</p>
<pre><code class="language-conf">maxConns = 1000000
fork = false
port = 27017
pidfilepath = /var/run/mongodb_27017.pid
dbpath = /var/lib/mongodb/
logpath = /var/log/mongodb/mongodb.log
logappend = true
bind_ip  = 0.0.0.0
auth = true                         #启动认证模块
journal = true
</code></pre>
<p>重新启动即可</p>
<h1 id="docker部署">docker部署</h1>
<h2 id="docker-compose">docker-compose</h2>
<pre><code class="language-yml">version: '2'
services:
  mongodb:
    image: mongo
    ports:
        - 27017:27017
    volumes:
        - &quot;./data/configdb:/data/configdb&quot;
        - &quot;./data/db:/data/db&quot;
    command: mongod --auth
    environment:
      - MONGO_INITDB_ROOT_USERNAME=root       #初始化管理员用户名和密码
      - MONGO_INITDB_ROOT_PASSWORD=123456
    tty: true
</code></pre>
<h2 id="带上mongo-expressweb管理页面">带上mongo-express，web管理页面。</h2>
<pre><code class="language-yml"># Use root/example as user/password credentials
version: '3.1'

services:

  mongo:
    image: mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: root
    # command: [&quot;--bind_ip_all&quot;]
    ports:
      - &quot;27017:27017&quot;

  mongo-express:
    image: mongo-express
    restart: always
    ports:
      - 8081:8081
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: root
      ME_CONFIG_MONGODB_ADMINPASSWORD: root
</code></pre>
<p>运行docker ps查看容器是否运行。</p>
<p>进入docker容器并进入mongo命令行。</p>
<pre><code class="language-bash">docker exec -it  test bash
mongo
</code></pre>
<p>此时show dbs无法执行，需要认证。<br>
切换到admin并创建root用户：</p>
<pre><code class="language-bash">use admin
db.createUser({ user: 'admin', pwd: 'admin', roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ] })
</code></pre>
<h2 id="3-创建其他的账号">3. 创建其他的账号</h2>
<pre><code class="language-bash">&gt; use admin
switched to db admin
&gt; db.auth(&quot;admin&quot;, &quot;admin&quot;)
1
&gt; db.createUser(
... {
...  user : &quot;my_tester&quot;,
...  pwd : &quot;123456&quot;,
...  roles: [ { role : &quot;readWrite&quot;, db : &quot;test&quot; }  ]
... }
... )
Successfully added user: {
        &quot;user&quot; : &quot;my_tester&quot;,
        &quot;roles&quot; : [
                {
                        &quot;role&quot; : &quot;readWrite&quot;,
                        &quot;db&quot; : &quot;test&quot;
                }
        ]
}
</code></pre>
<h2 id="权限说明基于角色的权限控制">权限说明（基于角色的权限控制）</h2>
<h3 id="数据库用户角色">数据库用户角色</h3>
<p>read: 只读数据权限<br>
readWrite:学些数据权限<br>
<strong>数据库管理角色</strong></p>
<ul>
<li>dbAdmin: 在当前db中执行管理操作的权限</li>
<li>dbOwner: 在当前db中执行任意操作</li>
<li>userADmin: 在当前db中管理user的权限<br>
<strong>备份和还原角色</strong></li>
<li>backup</li>
<li>restore<br>
<strong>夸库角色</strong></li>
<li>readAnyDatabase: 在所有数据库上都有读取数据的权限</li>
<li>readWriteAnyDatabase: 在所有数据库上都有读写数据的权限</li>
<li>userAdminAnyDatabase: 在所有数据库上都有管理user的权限</li>
<li>dbAdminAnyDatabase: 管理所有数据库的权限<br>
<strong>集群管理</strong></li>
<li>clusterAdmin: 管理机器的最高权限</li>
<li>clusterManager: 管理和监控集群的权限</li>
<li>clusterMonitor: 监控集群的权限</li>
<li>hostManager: 管理Server<br>
<strong>超级权限</strong></li>
<li>root: 超级用户</li>
</ul>
<h3 id="52-自定义角色">5.2 自定义角色</h3>
<p>内置角色只能控制User在DB级别上执行的操作，管理员可以创建自定义角色，控制用户在集合级别（Collection-Level）上执行的操作，即，控制User在当前DB的特定集合上执行特定的操作</p>
<h2 id="基本命令">基本命令</h2>
<p><strong>查看创建的用户</strong></p>
<pre><code class="language-bash">show users 或 db.system.users.find() 或 db.runCommand({usersInfo:&quot;userName&quot;})
</code></pre>
<p><strong>修改密码</strong></p>
<pre><code class="language-bash">use admin
db.changeUserPassword(&quot;username&quot;, &quot;xxx&quot;)
</code></pre>
<p><strong>修改密码和用户信息</strong></p>
<pre><code class="language-bash">db.runCommand(
    {
        updateUser:&quot;username&quot;,
        pwd:&quot;xxx&quot;,
        customData:{title:&quot;xxx&quot;}
    }
)
</code></pre>
<p><strong>删除数据库用户</strong></p>
<pre><code class="language-bash">use admin
db.dropUser('user001')
</code></pre>
<p><strong>创建其他数据管理员</strong></p>
<pre><code class="language-bash">// 登录管理员用户
use admin
db.auth('admin','admin')
// 切换至db001数据库
use db001
// ... 増查改删该数据库专有用户
</code></pre>
<h2 id="重要的一步">重要的一步</h2>
<p>启用权限验证(别TM的武装了大半天，大门还一直开着，还抱怨我方防御塔怎么一直被摧毁)</p>
<pre><code class="language-bash">mongo --auth
</code></pre>
<p>或者修改mongo.conf，最后一行添加</p>
<pre><code class="language-bash">#启用权限访问
auth=true
</code></pre>
<p>参考自：https://www.jianshu.com/p/62736bff7e2e</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell脚本输出带颜色字体]]></title>
        <id>https://chriswsq.github.io/post/shell-jiao-ben-shu-chu-dai-yan-se-zi-ti/</id>
        <link href="https://chriswsq.github.io/post/shell-jiao-ben-shu-chu-dai-yan-se-zi-ti/">
        </link>
        <updated>2020-12-30T09:45:10.000Z</updated>
        <content type="html"><![CDATA[<p>输出特效格式控制：<br>
\033[0m  关闭所有属性<br>
\033[1m   设置高亮度<br>
\03[4m   下划线<br>
\033[5m   闪烁<br>
\033[7m   反显<br>
\033[8m   消隐<br>
\033[30m   --   \033[37m   设置前景色<br>
\033[40m   --   \033[47m   设置背景色</p>
<p>光标位置等的格式控制：<br>
\033[nA  光标上移n行<br>
\03[nB   光标下移n行<br>
\033[nC   光标右移n行<br>
\033[nD   光标左移n行<br>
\033[y;xH设置光标位置<br>
\033[2J   清屏<br>
\033[K   清除从光标到行尾的内容<br>
\033[s   保存光标位置<br>
\033[u   恢复光标位置<br>
\033[?25l   隐藏光标</p>
<p>\33[?25h   显示光标</p>
<p>整理：<br>
编码 颜色/动作<br>
　　0   重新设置属性到缺省设置<br>
　　1   设置粗体<br>
　　2   设置一半亮度(模拟彩色显示器的颜色)<br>
　　4   设置下划线(模拟彩色显示器的颜色)<br>
　　5   设置闪烁<br>
　　7   设置反向图象<br>
　　22 设置一般密度<br>
　　24 关闭下划线<br>
　　25 关闭闪烁<br>
　　27 关闭反向图象<br>
　　30 设置黑色前景<br>
　　31 设置红色前景<br>
　　32 设置绿色前景<br>
　　33 设置棕色前景<br>
　　34 设置蓝色前景<br>
　　35 设置紫色前景<br>
　　36 设置青色前景<br>
　　37 设置白色前景<br>
　　38 在缺省的前景颜色上设置下划线<br>
　　39 在缺省的前景颜色上关闭下划线<br>
　　40 设置黑色背景<br>
　　41 设置红色背景<br>
　　42 设置绿色背景<br>
　　43 设置棕色背景<br>
　　44 设置蓝色背景<br>
　　45 设置紫色背景<br>
　　46 设置青色背景<br>
　　47 设置白色背景<br>
　　49 设置缺省黑色背景<br>
特效可以叠加，需要使用“;”隔开，例如：闪烁+下划线+白底色+黑字为   \033[5;4;47;30m闪烁+下划线+白底色+黑字为\033[0m<br>
下面是一段小例子</p>
<p>[plain] view plain copy<br>
#!/bin/bash</p>
<h1 id=""></h1>
<p>#下面是字体输出颜色及终端格式控制<br>
#字体色范围：30-37<br>
echo -e &quot;\033[30m 黑色字 \033[0m&quot;<br>
echo -e &quot;\033[31m 红色字 \033[0m&quot;<br>
echo -e &quot;\033[32m 绿色字 \033[0m&quot;<br>
echo -e &quot;\033[33m 黄色字 \033[0m&quot;<br>
echo -e &quot;\033[34m 蓝色字 \033[0m&quot;<br>
echo -e &quot;\033[35m 紫色字 \033[0m&quot;<br>
echo -e &quot;\033[36m 天蓝字 \033[0m&quot;<br>
echo -e &quot;\033[37m 白色字 \033[0m&quot;<br>
#字背景颜色范围：40-47<br>
echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;<br>
echo -e &quot;\033[41;30m 红底黑字 \033[0m&quot;<br>
echo -e &quot;\033[42;34m 绿底蓝字 \033[0m&quot;<br>
echo -e &quot;\033[43;34m 黄底蓝字 \033[0m&quot;<br>
echo -e &quot;\033[44;30m 蓝底黑字 \033[0m&quot;<br>
echo -e &quot;\033[45;30m 紫底黑字 \033[0m&quot;<br>
echo -e &quot;\033[46;30m 天蓝底黑字 \033[0m&quot;<br>
echo -e &quot;\033[47;34m 白底蓝字 \033[0m&quot;</p>
<p>#控制选项说明<br>
#\033[0m 关闭所有属性<br>
#\033[1m 设置高亮度<br>
#\033[4m 下划线<br>
echo -e &quot;\033[4;31m 下划线红字 \033[0m&quot;<br>
#闪烁<br>
echo -e &quot;\033[5;34m 红字在闪烁 \033[0m&quot;<br>
#反影<br>
echo -e &quot;\033[8m 消隐 \033[0m &quot;</p>
<p>#\033[30m-\033[37m 设置前景色<br>
#\033[40m-\033[47m 设置背景色<br>
#\033[nA光标上移n行<br>
#\033[nB光标下移n行<br>
echo -e &quot;\033[4A 光标上移4行 \033[0m&quot;<br>
#\033[nC光标右移n行<br>
#\033[nD光标左移n行<br>
#\033[y;xH设置光标位置<br>
#\033[2J清屏<br>
#\033[K清除从光标到行尾的内容<br>
echo -e &quot;\033[K 清除光标到行尾的内容 \033[0m&quot;<br>
#\033[s 保存光标位置<br>
#\033[u 恢复光标位置<br>
#\033[?25| 隐藏光标<br>
#\033[?25h 显示光标<br>
echo -e &quot;\033[?25l 隐藏光标 \033[0m&quot;<br>
echo -e &quot;\033[?25h 显示光标 \033[0m&quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cita链管理升级步骤]]></title>
        <id>https://chriswsq.github.io/post/cita-lian-guan-li-sheng-ji-bu-zou/</id>
        <link href="https://chriswsq.github.io/post/cita-lian-guan-li-sheng-ji-bu-zou/">
        </link>
        <updated>2020-12-30T09:21:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="链管理升级步骤">链管理升级步骤：</h1>
<ol>
<li>
<h3 id="停止链管理服务">停⽌链管理服务</h3>
</li>
</ol>
<pre><code>kill $(cat /bsn/cita-manager/bsn-cita-chain-manager-v0.1/gunicorn.pid) 
</code></pre>
<ol start="2">
<li>
<h3 id="备份程序文件">备份程序文件</h3>
</li>
</ol>
<pre><code class="language-bash">cp -rf /bsn/cita-manager/bsn-cita-chain-manager-v0.1 /bsn/cita-manager/bsn-cita-chain-manager-v0.1.20201229
</code></pre>
<ol start="3">
<li>
<h3 id="解压新代码包并将文件拷至老目录">解压新代码包并将⽂件拷⻉⾄⽼⽬录</h3>
</li>
</ol>
<pre><code class="language-shell">tar xzvf bsn-cita-chain-manager-develop.tar.gz

yes | cp -rf bsn-cita-chain-manager-develop/.   /bsn/cita-manager/bsn-cita-chain-manager-v0.1
</code></pre>
<ol start="3">
<li>修改数据库密码</li>
</ol>
<pre><code class="language-bash"> cd  /bsn/cita-manager/bsn-cita-chain-manager-v0.1
 修改cita.db中的表node  字段pwd
 
xxxxxxxx

加密后的字符串为:

xxxxxxxxxxxxxxxxxxx
</code></pre>
<ol start="3">
<li>
<h3 id="进入原链管理服务目录执行升级命令">进⼊原链管理服务⽬录，执⾏升级命令</h3>
</li>
</ol>
<pre><code class="language-shell"> cd /bsn/cita-manager/bsn-cita-chain-manager-v0.1

 rm -rf logs 

 make update 
</code></pre>
<ol start="4">
<li>
<h3 id="将原来产生的链配置复制到链管理服务目录">将原来产⽣的链配置复制到链管理服务⽬录</h3>
</li>
</ol>
<pre><code class="language-shell">mkdir chain-config 

cp -rf /opt/all-chain-config/. /bsn/cita-manager/bsn-cita-chain-manager-v0.1/chain-config/ 

make start 
</code></pre>
<p>节点管理升级步骤：</p>
<ol>
<li>运行数据库脚本：   dml20201118/ddl.sql    dml20201118/dml.sql</li>
<li>运行数据库脚本：  update tb_cita_nodeinfo set status=1;   先执行ddl  再执行dml</li>
<li>重新部署war包</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[aws-- Amazon  API  Gateway功能]]></title>
        <id>https://chriswsq.github.io/post/aws-amazon-api-gateway-gong-neng/</id>
        <link href="https://chriswsq.github.io/post/aws-amazon-api-gateway-gong-neng/">
        </link>
        <updated>2020-12-24T08:51:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="支持的api">支持的API</h2>
<p>RESTful API、WebSocket API、HTTP API 和 REST API 私有 （只能从vpc访问的REST API）</p>
<h2 id="特点">特点</h2>
<p><strong>规则限流</strong><br>
为API中每个HTTP方法设置限制规则，管理指向后端系统的流量</p>
<p><strong>监控</strong><br>
API调用次数，延迟和错误率，设置自定义报警</p>
<p><strong>授权</strong><br>
身份认证，连接管理，访问策略，lambda函数验证持有者令牌，（jwt令牌或saml断言）</p>
<p><strong>秘钥</strong><br>
REST API 可在gateway上创建API 秘钥，并设置权限，将其分发给第三方开发人员以访问API</p>
<p><strong>生成开发工具包</strong><br>
REST API 可以为大量平台生成客户端开发工具包，测试新API，分发给第三方开发人员。API Gateway 可以生成适用于 Java、JavaScript、Java for Android、Objective-C 或 Swift for iOS 和 Ruby 的客户端开发工具包。可以使用 AWS CLI，通过调用 get-sdk 命令为支持的平台生成 API 的开发工具包并下载。</p>
<p><strong>API 生命周期管理</strong><br>
REST API，API Gateway 使您可以同时运行同一 API 的多个版本，管理每个 API 版本的多个发布阶段</p>
<p><strong>功能</strong><br>
<strong>REST API</strong><br>
API网关提供了REST API管理功能，例如：<br>
支持使用OpenAPI的API网关扩展来生成SDK和创建API文档<br>
限制HTTP请求<br>
<strong>WebSocket API</strong><br>
API网关提供WebSocket API管理功能，例如：<br>
监视和限制连接和消息<br>
使用AWS X-Ray跟踪通过API传递到后端服务的消息<br>
轻松与HTTP / HTTPS端点集成</p>
<p>rest api<br>
客户端证书，秘钥</p>
<p>websocke  api<br>
客户端证书</p>
<p>http  api<br>
限制（路由限制和突增限制）   能监控  日志</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quorum、tessera、cakeshop服务基本知识]]></title>
        <id>https://chriswsq.github.io/post/quorumtesseracakeshop-fu-wu-ji-ben-zhi-shi/</id>
        <link href="https://chriswsq.github.io/post/quorumtesseracakeshop-fu-wu-ji-ben-zhi-shi/">
        </link>
        <updated>2020-12-14T08:10:18.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>quorum分别有两个共识<br>
raft、bft</p>
</li>
<li>
<p>quorum依赖环境<br>
go</p>
</li>
<li>
<p>quorum节点分类<br>
bft共识分为：验证节点和非验证节点。验证节点可以作为主节点的备份，非验证节点只同步数据</p>
</li>
<li>
<p>tessera为私人交易管理器<br>
通常的方式创建为彼岸准的以太坊交易，私有交易不会按标准的以太坊执行：在发送方的GoQuorum节点将交易传播到网络的其余部分之前，它将原始交易有效载荷替换为从Constellation / Tessera接收到的加密有效载荷的哈希值。参与交易的参与者将能够通过其Constellation / Tessera实例将哈希值替换为实际有效载荷，而未参与交易的参与者将只能看到哈希值。</p>
</li>
<li>
<p>quorum创始块文件为genesis.json</p>
</li>
<li>
<p>quorum集群连接信息配置在static-nodes.json文件</p>
</li>
<li>
<p>tessera的配置文件为tessera-config.json</p>
</li>
<li>
<p>Cakeshop 为quorum服务的web管理器</p>
</li>
<li>
<p>cakeshop的配置文件为application.properties</p>
</li>
<li>
<p>cakeshop连接quorum节点连接信息的文件为nodes.json</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker-compose启动quorum、tessera、cakeshop--raft共识]]></title>
        <id>https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/</id>
        <link href="https://chriswsq.github.io/post/docker-compose-qi-dong-quorumtesseracakeshop/">
        </link>
        <updated>2020-12-14T07:09:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker-compose文件">docker-compose文件</h2>
<pre><code class="language-yml">version: &quot;3.6&quot;
x-quorum-def:
  &amp;quorum-def
  restart: &quot;on-failure&quot;
  image: quorumengineering/quorum:20.10.0
  expose:
    - &quot;21000&quot;
    - &quot;50000&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy&quot;, &quot;off&quot;, &quot;http://localhost:22000&quot;]
    interval: 3s
    timeout: 3s
    retries: 10
    start_period: 5s
  labels:
    com.quorum.consensus: raft
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/dd
      cat $${DDIR}/static-nodes.json
      GENESIS_FILE=&quot;$${DDIR}/genesis.json&quot;
      NETWORK_ID=$$(cat $${GENESIS_FILE} | grep chainId | awk -F &quot; &quot; '{print $$2}' | awk -F &quot;,&quot; '{print $$1}')
      geth --datadir $${DDIR} init $${GENESIS_FILE}
      geth \
        --identity node1-raft \
        --datadir $${DDIR} \
        --permissioned \
        --nodiscover \
        --verbosity 5 \
        --networkid $${NETWORK_ID} \
        --rpc \
        --raft \
        --raftport 50000 \
        --rpcaddr 0.0.0.0 \
        --rpcport 22000 \
        --rpcapi admin,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft \
        --port 21000 \
        --unlock 0 \
        --allow-insecure-unlock \
        --nousb \
        --password $${DDIR}/passwords.txt \
x-tx-manager-def:
  &amp;tx-manager-def
  image: quorumengineering/tessera:20.10.0
  expose:
    - &quot;9000&quot;
    - &quot;9080&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD-SHELL&quot;, &quot;[ -S /qdata/tm/tm.ipc ] || exit 1&quot;]
    interval: 3s
    timeout: 3s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      if [ &quot;$${PRIVATE_CONFIG}&quot; == &quot;ignore&quot; ]; then
        /bin/true
        exit 0
      fi
      DDIR=/qdata/tm
      mkdir -p $${DDIR}
          #extract the tessera version from the jar
          TESSERA_VERSION=$$(unzip -p /tessera/tessera-app.jar META-INF/MANIFEST.MF | grep Tessera-Version | cut -d&quot; &quot; -f2)
          #generating the two config flavors
          cat &lt;&lt;EOF &gt; $${DDIR}/tessera-config.json
          {
            &quot;useWhiteList&quot;: false,
            &quot;jdbc&quot;: {
              &quot;username&quot;: &quot;sa&quot;,
              &quot;password&quot;: &quot;&quot;,
              &quot;url&quot;: &quot;jdbc:h2:./$${DDIR}/db;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
              &quot;autoCreateTables&quot;: true
            },
            &quot;serverConfigs&quot;:[
            {
              &quot;app&quot;:&quot;ThirdParty&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9080&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;Q2T&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;unix:$${DDIR}/tm.ipc&quot;,
              &quot;communicationType&quot; : &quot;REST&quot;
            },
            {
              &quot;app&quot;:&quot;P2P&quot;,
              &quot;enabled&quot;: true,
              &quot;serverAddress&quot;: &quot;http://192.168.40.6:9000&quot;,
              &quot;sslConfig&quot;: {
                &quot;tls&quot;: &quot;OFF&quot;
              },
              &quot;communicationType&quot; : &quot;REST&quot;
            }
            ],
            &quot;peer&quot;: [
               {
                   &quot;url&quot;: &quot;http://192.168.40.6:9000&quot;
               },
               {
                   &quot;url&quot;: &quot;http://192.168.40.7:9000&quot;
               }
            ],
            &quot;keys&quot;: {
              &quot;passwords&quot;: [],
              &quot;keyData&quot;: [
                {
                  &quot;config&quot;: $$(cat $${DDIR}/tm.key),
                  &quot;publicKey&quot;: &quot;$$(cat $${DDIR}/tm.pub)&quot;
                }
              ]
            },
            &quot;alwaysSendTo&quot;: []
          }
      EOF
          cat $${DDIR}/tessera-config.json
          java -Xms128M -Xmx128M -jar /tessera/tessera-app.jar -configfile $${DDIR}/tessera-config.json
x-cakeshop-def:
  &amp;cakeshop-def
  image: &quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
  expose:
    - &quot;8999&quot;
  restart: &quot;no&quot;
  healthcheck:
    test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;--proxy=off&quot;, &quot;http://localhost:8999/actuator/health&quot;]
    interval: 5s
    timeout: 5s
    retries: 20
    start_period: 5s
  entrypoint:
    - /bin/sh
    - -c
    - |
      DDIR=/qdata/cakeshop/local
      mkdir -p $${DDIR}
      DOCKER_IMAGE=&quot;${CAKESHOP_DOCKER_IMAGE:-quorumengineering/cakeshop:0.11.0}&quot;
      java -Xms128M -Xmx128M -Dcakeshop.config.dir=/qdata/cakeshop -Dlogging.path=/qdata/logs/cakeshop -jar /opt/cakeshop/cakeshop.war
      ;;
services:
  node1:
    &lt;&lt; : *quorum-def
    hostname: node1
    ports:
      - &quot;22000:22000&quot;
      - &quot;21000:21000&quot;
      - &quot;50000:50000&quot;
    volumes:
      - ./data:/qdata
    depends_on:
      - txmanager1
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.11
  txmanager1:
    &lt;&lt; : *tx-manager-def
    hostname: txmanager1
    ports:
      - &quot;9080:9080&quot;
    volumes:
      - ./data:/qdata
    networks:
      quorum-examples-net:
        ipv4_address: 172.16.239.101
    environment:
      - PRIVATE_CONFIG=${PRIVATE_CONFIG:-/qdata/tm/tm.ipc}

  cakeshop:
    &lt;&lt; : *cakeshop-def
    hostname: cakeshop
    ports:
      - &quot;8999:8999&quot;
    volumes:
      - ./data:/qdata

networks:
  quorum-examples-net:
    name: quorum-examples-net
    driver: bridge
    ipam:
      driver: default
      config:
      - subnet: 172.16.239.0/24
</code></pre>
<h2 id="挂载所需文件及目录">挂载所需文件及目录</h2>
<p>当前目录为 /bsn/quorum</p>
<p>data<br>
|---  cakeshop<br>
|-------|-- local<br>
|------------|-- application.properties<br>
|------------|-- nodes.json<br>
|<br>
| --- dd<br>
|------|-- genesis.json<br>
|------|-- keystore<br>
|------|------|-- key<br>
|------|-- passwords.txt<br>
|------|--  permissioned-nodes.json<br>
|------|-- static-nodes.json<br>
|------|-- disallowed-nodes.json<br>
|<br>
|---- tm<br>
------|-- tessera-config.json</p>
<h3 id="cakeshop-挂载文件">cakeshop 挂载文件</h3>
<p><strong>application.properties文件为cakeshop的配置文件，配置服务端口，链接文件，安全配置等</strong></p>
<pre><code class="language-yml">#Mon Dec 14 07:18:51 UTC 2020
spring.main.banner-mode=off
security.ignored=/**
geth.log=/logs
spring.mvc.view.suffix=.jsp
geth.auto.stop=false
geth.identity=bradmcdermott
geth.cors.url=
endpoints.actuator.enabled=true
security.basic.enabled=false
nodejs.binary=node
contract.poll.delay.millis=5000
geth.mining=true
cakeshop.initialnodes=qdata/cakeshop/local/nodes.json
geth.node.port=30303
geth.cors.enabled=false
management.security.enabled=false
server.port=8999
geth.release.url=
server.compression.enabled=true
geth.url=http\://localhost\:8102
geth.vote.contract.addr=0x0000000000000000000000000000000000000020
cakeshop.hibernate.jdbc.batch_size=20
cakeshop.database.vendor=hsqldb
geth.consensus.mode=raft
geth.tools.url=
cakeshop.mvc.async.pool.threads.max=1000
cakeshop.jdbc.user=sdk
geth.transaction_manager.url=http\://localhost\:9102
spring.mvc.view.prefix=/WEB-INF/jsp/
geth.verbosity=
geth.auto.start=false
cakeshop.hibernate.hbm2ddl.auto=update
cakeshop.selected_node=1
geth.raft.network.id=
geth.istanbul.url=
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain
geth.bootnode.address=
cakeshop.mvc.async.pool.queue.max=2000
cakeshop.mvc.async.pool.threads.core=250
management.context-path=/manage
geth.db.enabled=true
geth.cred1=admin
geth.datadir=/qdata/cakeshop/local/ethereum
geth.raft.port=22000
geth.cred2=$2a$10$dbGiTnfK/w8MhcpIj3XgROYXRsFMlEYJRWoUYArkr8aSPypUFV25G
geth.params.extra=
geth.raft.blocktime=100
geth.bootnodes.list=
geth.networkid=1006
geth.bootnode.key=
geth.startup.mode=standalone
cakeshop.jdbc.pass=sdk
geth.transaction_manager.peers=http\://localhost\:9102
geth.rpcapi.list=admin,db,eth,debug,miner,net,shh,txpool,personal,web3
log4j.rootLogger=DEBUG, stdout
contract.registry.addr=
geth.unlock.timeout=5000
</code></pre>
<p><strong>nodes.json 文件配置连接quorum服务节点的地址(也可可续在web页面添加)</strong></p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;node1&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.6:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.6:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node2&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.7:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.7:9080&quot;
  },
  {
    &quot;name&quot;: &quot;node3&quot;,
    &quot;rpcUrl&quot;: &quot;http://192.168.40.8:22000&quot;,
    &quot;transactionManagerUrl&quot;: &quot;http://192.168.40.8:9080&quot;
  }
]
</code></pre>
<h3 id="quorum挂载文件">quorum挂载文件</h3>
<ul>
<li>disallowed-nodes.json：禁止访问定义</li>
<li>keysstore/key：创建用户的账号key存储</li>
<li>genesis.json：创世块文件</li>
<li>passwords.txt：解锁密钥存储</li>
<li>permissioned-nodes.json：允许访问定义列表</li>
<li>static-nodes.json：集群节点连接信息</li>
</ul>
<p><strong>disallowed-nodes.json</strong></p>
<pre><code class="language-bash">[
]
</code></pre>
<p><strong>keysstore/key</strong><br>
账户文件通过命令提前生成<br>
生成的key名字可以更改，密码最好设置为空</p>
<pre><code class="language-bash">geth --datadir dd account new
ll data/dd/keystore/
UTC--2020-12-07T03-33-12.115191344Z--93f0b48f9d921f38dabff36cb682bfb208472221
</code></pre>
<p><strong>genesis.json</strong></p>
<p>文件内的alloc参数根据创建的账户文件生成的key来填写</p>
<pre><code class="language-json">{
  &quot;alloc&quot;: {
    &quot;0xCcfaC6Cfb21D1f10C915d0e4189586765c30089e&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    },
    &quot;0x1ff1a9c504703b8e623640be516e768f3d175d14&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    }
  },
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;config&quot;: {
    &quot;homesteadBlock&quot;: 0,
    &quot;byzantiumBlock&quot;: 0,
    &quot;constantinopleBlock&quot;: 0,
    &quot;petersburgBlock&quot;: 0,
    &quot;istanbulBlock&quot;: 0,
    &quot;chainId&quot;: 10,
    &quot;eip150Block&quot;: 0,
    &quot;eip155Block&quot;: 0,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip158Block&quot;: 0,
    &quot;isQuorum&quot;: true,
    &quot;maxCodeSizeConfig&quot; : [
      {
        &quot;block&quot; : 0,
        &quot;size&quot; : 32
      }
    ]
  },
  &quot;difficulty&quot;: &quot;0x0&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0xE0000000&quot;,
  &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;timestamp&quot;: &quot;0x00&quot;
}
</code></pre>
<p><strong>passwords.txt</strong><br>
最好为空，不然会与在页面创建的用户有冲突</p>
<pre><code class="language-bash">test
</code></pre>
<p><strong>permissioned-nodes.json</strong><br>
文件中的id使用命令提前生成</p>
<pre><code class="language-bash"> bootnode --genkey=nodekey
 cp nodekey 
 bootnode --nodekey=nodekey --writeaddress
</code></pre>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<p><strong>static-nodes.json</strong></p>
<pre><code class="language-bash">[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoQuorum之raft共识添加添加隐私交易管理器tessera--二进制]]></title>
        <id>https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/</id>
        <link href="https://chriswsq.github.io/post/goquorum-zhi-raft-gong-shi-tian-jia-tian-jia-yin-si-jiao-yi-guan-li-qi-tessera/">
        </link>
        <updated>2020-12-07T07:37:57.000Z</updated>
        <content type="html"><![CDATA[<p>tessera</p>
<p>公共与私人交易处理<br>
公共交易是以标准的以太坊方式执行的，因此，如果将公共交易发送到持有合同代码的账户，则每个参与者将执行相同的代码，并且其底层StateDB将相应地更新。</p>
<p>但是，私有交易不会按标准的以太坊执行：在发送方的GoQuorum节点将交易传播到网络的其余部分之前，它将原始交易有效载荷替换为从Constellation / Tessera接收到的加密有效载荷的哈希值。参与交易的参与者将能够通过其Constellation / Tessera实例将哈希值替换为实际有效载荷，而未参与交易的参与者将只能看到哈希值。</p>
<p>结果是，如果将私人交易发送到持有合同代码的帐户，则那些不参与交易的参与者将最终跳过交易，因此不执行合同代码。但是，参与交易的那些参与者将在调用EVM执行之前将哈希替换为原始有效负载，并且其StateDB将相应地更新。如果没有对geth客户进行相应的更改，那么这两组参与者最终将拥有不同的StateDB，并且无法达成共识。为了支持合同状态的这种分叉，Quorum将公共合同的状态存储在全局同步的Public State Trie中，</p>
<h2 id="安装goquorum和tessera">安装GoQuorum和tessera</h2>
<pre><code class="language-bash">$ git clone https://github.com/ConsenSys/quorum.git
$ cd quorum
$ make all
$ export PATH=$(pwd)/build/bin:$PATH
$ cd ..
.... copy tessera jar to your desired destination and rename it as tessera
$ mv tessera-app-20.10.0-app.jar tessera.jar
</code></pre>
<h2 id="生成新密钥">生成新密钥</h2>
<pre><code class="language-bash">$ mkdir new-node-1t
$ cd new-node-1t
$ java -jar ../tessera.jar -keygen -filename new-node-1
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:32:51.256 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:32:51.279 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[pnesVeDgs805ZPbnulzC5wokDzpdN7CeYKVUBXup/W4=] and private key REDACTED
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-1t/new-node-1.pub
10:32:51.624 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-1t/new-node-1.key
</code></pre>
<h2 id="创建configjson配置文件">创建config.json配置文件</h2>
<pre><code class="language-bash">{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-1t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.6:9081&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-1t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.6:9001&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-1t/new-node-1.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动其他节点">启动其他节点</h2>
<p>如果要启动另一个Tessera节点，请重复步骤2和步骤3</p>
<pre><code class="language-bash">$ cd ..
$ mkdir new-node-2t
$ cd new-node-2t
$ java -jar ../tessera.jar -keygen -filename new-node-2
Enter a password if you want to lock the private key or leave blank

Please re-enter the password (or lack of) to confirm

10:45:02.567 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generating new keypair...
10:45:02.585 [main] INFO  com.quorum.tessera.nacl.jnacl.Jnacl - Generated public key PublicKey[AeggpVlVsi+rxD6h9tcq/8qL/MsjyipUnkj1nvNPgTU=] and private key REDACTED
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved public key to /Users/krish/fromscratch/new-node-2t/new-node-2.pub
10:45:02.926 [main] INFO  c.q.t.k.generation.FileKeyGenerator - Saved private key to /Users/krish/fromscratch/new-node-2t/new-node-2.key
$
$ vim config.json

{
   &quot;useWhiteList&quot;: false,
   &quot;jdbc&quot;: {
       &quot;username&quot;: &quot;sa&quot;,
       &quot;password&quot;: &quot;&quot;,
       &quot;url&quot;: &quot;jdbc:h2:/bsn/quorum/fromscratch/new-node-2t/db1;MODE=Oracle;TRACE_LEVEL_SYSTEM_OUT=0&quot;,
       &quot;autoCreateTables&quot;: true
   },
   &quot;serverConfigs&quot;:[
       {
           &quot;app&quot;:&quot;ThirdParty&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;: &quot;http://192.168.40.7:9082&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;Q2T&quot;,
           &quot;enabled&quot;: true,
            &quot;serverAddress&quot;:&quot;unix:/bsn/quorum/fromscratch/new-node-2t/tm.ipc&quot;,
           &quot;communicationType&quot; : &quot;REST&quot;
       },
       {
           &quot;app&quot;:&quot;P2P&quot;,
           &quot;enabled&quot;: true,
           &quot;serverAddress&quot;:&quot;http://192.168.40.7:9002&quot;,
           &quot;sslConfig&quot;: {
               &quot;tls&quot;: &quot;OFF&quot;
           },
           &quot;communicationType&quot; : &quot;REST&quot;
       }
   ],
   &quot;peer&quot;: [
       {
           &quot;url&quot;: &quot;http://192.168.40.6:9001&quot;
       },
       {
           &quot;url&quot;: &quot;http://192.168.40.7:9002&quot;
       }
   ],
   &quot;keys&quot;: {
       &quot;passwords&quot;: [],
       &quot;keyData&quot;: [
           {
               &quot;privateKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.key&quot;,
               &quot;publicKeyPath&quot;: &quot;/bsn/quorum/fromscratch/new-node-2t/new-node-2.pub&quot;
           }
       ]
   },
   &quot;alwaysSendTo&quot;: []
}
</code></pre>
<h2 id="启动tessera节点">启动tessera节点</h2>
<p>启动您的Tessera节点，然后发送到后台<br>
分别在192.168.40.6   192.168.40.7执行</p>
<pre><code class="language-bash">java -jar ../tessera.jar -configfile config.json &gt;&gt; tessera.log 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="修改goquorum启动脚本">修改GoQuorum启动脚本</h2>
<p>从上方启动连接到正在运行的Tessera节点的GoQuorum节点并将其发送到后台</p>
<p>192.168.40.6</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-1t/tm.ipc nohup geth --allow-insecure-unlock  --datadir new-node-1 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<p>192.168.40.7</p>
<pre><code class="language-bash">vim startnode1.sh
#!/bin/bash
PRIVATE_CONFIG=/bsn/quorum/fromscratch/new-node-2t/tm.ipc nohup geth --allow-insecure-unlock --datadir new-node-2 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;
</code></pre>
<blockquote>
<p>注意：<br>
Tessera IPC桥接器将位于您定义的文件名上config.json，通常以tm.ipc前缀中的名称命名PRIVATE_CONFIG=tm.ipc。您的节点现在可以发送和接收私人交易，播发的公共节点密钥将在new-node-1.pub文件中。Tessera提供了很多配置灵活性，有关完整和最新的配置选项，请参阅Tessera下的“配置”部分。<br>
--allow-insecure-unlock  用于解锁用户</p>
</blockquote>
<h2 id="发送私人交易">发送私人交易</h2>
<p>您的节点现在可以运行了，您可以附加到该节点geth attach new-node-1/geth.ipc以发送私人交易。</p>
<pre><code class="language-bash">$ vim private-contract.js
... create simple private contract to send transaction from new-node-1 private for new-node-2's tessera public key created in step 4
a = eth.accounts[0]
web3.eth.defaultAccount = a;

// abi and bytecode generated from simplestorage.sol:
// &gt; solcjs --bin --abi simplestorage.sol
var abi = [{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;storedData&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;x&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;set&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;get&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;retVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;name&quot;:&quot;initVal&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;constructor&quot;}];

var bytecode = &quot;0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029&quot;;

var simpleContract = web3.eth.contract(abi);
var simple = simpleContract.new(42, {from:web3.eth.accounts[0], data: bytecode, gas: 0x47b760, privateFor: [&quot;R5qs4JXQ+aiJqh2V98qgbPZj+rR82ZodCq2CAUyIJjw=&quot;]}, function(e, contract) {
    if (e) {
        console.log(&quot;err creating contract&quot;, e);
    } else {
        if (!contract.address) {
            console.log(&quot;Contract transaction send: TransactionHash: &quot; + contract.transactionHash + &quot; waiting to be mined...&quot;);
        } else {
            console.log(&quot;Contract mined! Address: &quot; + contract.address);
            console.log(contract);
        }
    }
});
$
$
</code></pre>
<blockquote>
<p>注意： 默认情况下，在geth中打开的帐户是锁定的，因此在发送交易之前，请先解锁帐户，所以启动需要加上--allow-insecure-unlock参数，不然解锁用户时会报错Error: account unlock with HTTP access is forbidden</p>
</blockquote>
<pre><code class="language-bash">
[root@test-1 fromscratch]# geth attach new-node-1/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.9.7-stable-7b726385(quorum-v20.10.0)/linux-amd64/go1.15.1
coinbase: 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
at block: 0 (Thu, 01 Jan 1970 08:00:00 CST)
 datadir: /bsn/quorum/fromscratch/new-node-1
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 quorumExtension:1.0 raft:1.0 rpc:1.0 txpool:1.0 web3:1.0

&gt; eth.accounts
[&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;, &quot;0x93f0b48f9d921f38dabff36cb682bfb208472221&quot;]
&gt; personal.unlockAccount(&quot;0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65&quot;);
Unlock account 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
Password: 
true
&gt; loadScript(&quot;private-contract.js&quot;)
Contract transaction send: TransactionHash: 0xfaf11707339302bc62bfbfe6968ea20e5b511fc1450f799a5ac95a91a512c8fa waiting to be mined...
true
&gt; Contract mined! Address: 0xb85f26e18472df8c33633990b8ba8eb7d012966c
[object Object]

</code></pre>
<p>您已成功将私有事务从节点1发送到节点2！</p>
<blockquote>
<p>注意：如果private-contract.js中的数组中没有有效的公共密钥，则在加载脚本时会看到以下错误。</p>
</blockquote>
<pre><code class="language-bash">&gt; loadScript(&quot;private-contract.js&quot;)
err creating contract Error: Non-200 status code: &amp;{Status:400 Bad Request StatusCode:400 Proto:HTTP/1.1 ProtoMajor:1      ProtoMinor:1 Header:map[Date:[Mon, 17 Jun 2019 15:23:53 GMT] Content-Type:[text/plain] Content-Length:[73] Server:[Jetty(9.4.z-SNAPSHOT)]] Body:0xc01997a580 ContentLength:73 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc019788200 TLS:&lt;nil&gt;}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多机部署GoQuorum之raft共识--二进制]]></title>
        <id>https://chriswsq.github.io/post/er-jin-zhi-duo-ji-bu-shu-goquorum-zhi-raft-gong-shi/</id>
        <link href="https://chriswsq.github.io/post/er-jin-zhi-duo-ji-bu-shu-goquorum-zhi-raft-gong-shi/">
        </link>
        <updated>2020-12-07T02:38:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="goquorum与raft达成共识">GoQuorum与Raft达成共识</h2>
<h3 id="测试环境">测试环境</h3>
<ul>
<li>2台主机<br>
192.168.40.6(test-1)           192.168.40.7(test-2)</li>
</ul>
<h3 id="下载安装程序文件">下载安装程序文件</h3>
<pre><code class="language-bash"> git clone https://github.com/ConsenSys/quorum.git
 cd quorum
 make all
 export PATH=$(pwd)/build/bin:$PATH
</code></pre>
<h3 id="创建服务目录">创建服务目录</h3>
<pre><code class="language-bash">mkdir fromscratch
cd fromscratch
mkdir new-node-1
</code></pre>
<h3 id="创建账户">创建账户</h3>
<p>为该节点生成一个或多个帐户并记下帐户地址。根据您要完成的工作，可能需要一个资金帐户</p>
<pre><code class="language-bash">[root@test-1 fromscratch]#  geth --datadir new-node-1 account new
INFO [12-07|11:29:07.567] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|11:29:07.567] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
Your new account is locked with a password. Please give a password. Do not forget this password.
Password: 
Repeat password: 

Your new key was generated

Public address of the key:   0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65
Path of the secret key file: new-node-1/keystore/UTC--2020-12-07T03-30-11.929565315Z--4cccda1f9bc42a72c7a704bdc07f5f384483ff65

- You can share your public address with anyone. Others need it to interact with you.
- You must NEVER share the secret key with anyone! The key controls access to your funds!
- You must BACKUP your key file! Without the key, it's impossible to access account funds!
- You must REMEMBER your password! Without the password, it's impossible to decrypt the key!

[root@test-1 fromscratch]# geth --datadir new-node-1 account new
INFO [12-07|11:33:09.552] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|11:33:09.552] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
Your new account is locked with a password. Please give a password. Do not forget this password.
Password: 
Repeat password: 

Your new key was generated

Public address of the key:   0x93F0B48f9D921f38dabFf36CB682bfB208472221
Path of the secret key file: new-node-1/keystore/UTC--2020-12-07T03-33-12.115191344Z--93f0b48f9d921f38dabff36cb682bfb208472221

- You can share your public address with anyone. Others need it to interact with you.
- You must NEVER share the secret key with anyone! The key controls access to your funds!
- You must BACKUP your key file! Without the key, it's impossible to access account funds!
- You must REMEMBER your password! Without the password, it's impossible to decrypt the key!
</code></pre>
<h3 id="创世块文件">创世块文件</h3>
<p>genesis.json使用此处的示例创建文件。唯一需要进行的更改将是将在上一步中生成的帐户添加到该alloc字段，并为它们预先注资。例如，在这里我们为帐户0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65和0x93F0B48f9D921f38dabFf36CB682bfB208472221提供资金。</p>
<pre><code class="language-bash">vim genesis.json

{
  &quot;alloc&quot;: {
    &quot;0x4ccCdA1f9bc42A72C7a704bDC07F5F384483ff65&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    },
    &quot;0x93F0B48f9D921f38dabFf36CB682bfB208472221&quot;: {
      &quot;balance&quot;: &quot;1000000000000000000000000000&quot;
    }
  },
  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,
  &quot;config&quot;: {
    &quot;homesteadBlock&quot;: 0,
    &quot;byzantiumBlock&quot;: 0,
    &quot;constantinopleBlock&quot;: 0,
    &quot;chainId&quot;: 10,
    &quot;eip150Block&quot;: 0,
    &quot;eip155Block&quot;: 0,
    &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
    &quot;eip158Block&quot;: 0,
    &quot;maxCodeSizeConfig&quot;: [
      {
        &quot;block&quot;: 0,
        &quot;size&quot;: 35
      }
    ],
    &quot;isQuorum&quot;: true
  },
  &quot;difficulty&quot;: &quot;0x0&quot;,
  &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;gasLimit&quot;: &quot;0xE0000000&quot;,
  &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,
  &quot;nonce&quot;: &quot;0x0&quot;,
  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,
  &quot;timestamp&quot;: &quot;0x00&quot;
}

</code></pre>
<h3 id="生成节点密钥">生成节点密钥</h3>
<p>生成节点密钥并将其复制到datadir</p>
<pre><code class="language-bash"> bootnode --genkey=nodekey
 cp nodekey new-node-1/
</code></pre>
<h3 id="查看节点id">查看节点ID</h3>
<p>执行以下命令以显示新节点的enode ID</p>
<pre><code class="language-bash">bootnode --nodekey=new-node-1/nodekey --writeaddress &gt; new-node-1/enode
cat new-node-1/enode
f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d
</code></pre>
<h3 id="创建static-nodesjson文件">创建static-nodes.json文件</h3>
<p>创建一个名为的文件static-nodes.json并对其进行编辑以匹配此示例。您的文件应在您的节点中包含一行，并带有您的enode的ID以及将用于devp2p和Raft的端口。确保此文件在您的节点数据目录中</p>
<pre><code class="language-bash"> vim static-nodes.json
.... paste below lines with enode generated in previous step, port 21000;IP 127.0.0.1 and raft port set as 50000
[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<h3 id="初始化新节点">初始化新节点</h3>
<p>使用以下命令初始化新节点。</p>
<pre><code class="language-bash">[root@test-1 fromscratch]# geth --datadir new-node-1 init genesis.json
INFO [12-07|13:50:06.610] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|13:50:06.611] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
WARN [12-07|13:50:06.750] permission-config.json file is missing. Smart-contract-based permission service will be disabled error=&quot;stat new-node-1/permission-config.json: no such file or directory&quot;
INFO [12-07|13:50:06.750] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-1/geth/chaindata cache=16.00MiB handles=16
INFO [12-07|13:50:06.808] Writing custom genesis block 
INFO [12-07|13:50:06.829] Persisted trie from memory database      nodes=3 size=417.00B time=247.639µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|13:50:06.850] Successfully wrote genesis state         database=chaindata hash=e1236e…5fecf7
INFO [12-07|13:50:06.850] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-1/geth/lightchaindata cache=16.00MiB handles=16
INFO [12-07|13:50:06.855] Writing custom genesis block 
INFO [12-07|13:50:06.855] Persisted trie from memory database      nodes=3 size=417.00B time=92.049µs  gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|13:50:06.855] Successfully wrote genesis state         database=lightchaindata hash=e1236e…5fecf7
</code></pre>
<h3 id="创建启动脚本">创建启动脚本</h3>
<p>通过首先创建如下脚本然后启动它来启动节点：</p>
<pre><code class="language-bash"> vim startnode1.sh
... paste below commands. It will start it in the background.
#!/bin/bash
PRIVATE_CONFIG=ignore nohup geth --datadir new-node-1 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50000 --rpc --rpcaddr 0.0.0.0 --rpcport 22000 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21000 &gt;&gt; node.log 2&gt;&amp;1 &amp;

 chmod +x startnode1.sh
 ./startnode1.sh
</code></pre>
<blockquote>
<p>注意：如前缀所示PRIVATE_CONFIG=ignore，此配置将在没有隐私支持的情况下启动GoQuorum ，请参阅以下部分，了解如何通过隐私事务管理器启用隐私。</p>
</blockquote>
<p>您的节点现在可以运行了，您可以使用以下命令将其附加到该节点上。</p>
<pre><code class="language-bash">[root@test-1 fromscratch]# geth attach new-node-1/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.9.7-stable-7b726385(quorum-v20.10.0)/linux-amd64/go1.15.1
coinbase: 0x4cccda1f9bc42a72c7a704bdc07f5f384483ff65
at block: 0 (Thu, 01 Jan 1970 08:00:00 CST)
 datadir: /bsn/quorum/fromscratch/new-node-1
 modules: admin:1.0 debug:1.0 eth:1.0 ethash:1.0 miner:1.0 net:1.0 personal:1.0 raft:1.0 rpc:1.0 txpool:1.0 web3:1.0

&gt; raft.cluster
[{
    hostname: &quot;192.168.40.6&quot;,
    nodeActive: true,
    nodeId: &quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;,
    p2pPort: 21000,
    raftId: 1,
    raftPort: 50000,
    role: &quot;minter&quot;
}]
&gt; 
&gt; 
&gt; raft.leader
&quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;
&gt; raft.role
&quot;minter&quot;
&gt; exit
</code></pre>
<h2 id="添加其他节点">添加其他节点</h2>
<h3 id="完成上一指南中的步骤1-2-5和6">完成上一指南中的步骤1、2、5和6</h3>
<p>增加192.168.40.7为服务节点</p>
<pre><code class="language-bash">mkdir new-node-2
bootnode --genkey=nodekey2
cp nodekey2 new-node-2/nodekey
bootnode --nodekey=new-node-2/nodekey --writeaddress
3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d
</code></pre>
<h3 id="调整static-nodesjson">调整static-nodes.json</h3>
<pre><code class="language-bash">#在 192.168.40.6 上将static-nodes.json文件传至192.168.40.7
scp  static-nodes.json    root@192.168.40.7:/bsn/quorum/fromscratch/new-node-2

#编辑static-nodes.json并为您正在配置的新节点添加新条目（应该是最后一个）
vim new-node-2/static-nodes.json
[
  &quot;enode://f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d@192.168.40.6:21000?discport=0&amp;raftport=50000&quot;,
  &quot;enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000&quot;
]
</code></pre>
<h3 id="初始化新节点-2">初始化新节点</h3>
<pre><code class="language-bash">#将192.168.40.6的genesis.json文件拷贝至192.168.40.7
scp  genesis.json    root@192.168.40.7:/bsn/quorum/fromscratch/
[root@test-2 fromscratch]#  geth --datadir new-node-2 init genesis.json
INFO [12-07|14:19:55.539] Maximum peer count                       ETH=50 LES=0 total=50
INFO [12-07|14:19:55.542] Smartcard socket not found, disabling    err=&quot;stat /run/pcscd/pcscd.comm: no such file or directory&quot;
WARN [12-07|14:19:55.600] permission-config.json file is missing. Smart-contract-based permission service will be disabled error=&quot;stat new-node-2/permission-config.json: no such file or directory&quot;
INFO [12-07|14:19:55.603] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-2/geth/chaindata cache=16.00MiB handles=16
INFO [12-07|14:19:55.649] Writing custom genesis block 
INFO [12-07|14:19:55.693] Persisted trie from memory database      nodes=3 size=417.00B time=200.749µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|14:19:55.694] Successfully wrote genesis state         database=chaindata hash=e1236e…5fecf7
INFO [12-07|14:19:55.694] Allocated cache and file handles         database=/bsn/quorum/fromscratch/new-node-2/geth/lightchaindata cache=16.00MiB handles=16
INFO [12-07|14:19:55.698] Writing custom genesis block 
INFO [12-07|14:19:55.699] Persisted trie from memory database      nodes=3 size=417.00B time=1.166874ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [12-07|14:19:55.700] Successfully wrote genesis state         database=lightchaindata hash=e1236e…5fecf7
</code></pre>
<h3 id="连接到链中已运行的节点并执行raftaddpeer命令">连接到链中已运行的节点并执行RaftaddPeer命令。</h3>
<p>在192.168.40.6上执行</p>
<pre><code class="language-bash">&gt; raft.addPeer('enode://3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d@192.168.40.7:21000?discport=0&amp;raftport=50000')
2
&gt; raft.cluster
[{
    hostname: &quot;192.168.40.7&quot;,
    nodeActive: false,
    nodeId: &quot;3f2fe908035fa1ddcc3d80d504d1f2358675ca5f4aa3de4f0c5457ea9a2ae7d9af57688b4ec9f5b2772aa1b5c3da1e76840d27ea35d1bc4c86578b09b8d1a19d&quot;,
    p2pPort: 21000,
    raftId: 2,
    raftPort: 50000,
    role: &quot;verifier&quot;
}, {
    hostname: &quot;192.168.40.6&quot;,
    nodeActive: true,
    nodeId: &quot;f966b9a0cb82715fff5cc4b8f96c262c415181cb907cea5660bbd838c385976fd3a5389f40ea946d3dd02db2b5ac5f31bf760666d418cf7e340a8518bcdff03d&quot;,
    p2pPort: 21000,
    raftId: 1,
    raftPort: 50000,
    role: &quot;minter&quot;
}]

</code></pre>
<blockquote>
<p>新加的节点状态为false  因为还为启动节点二</p>
</blockquote>
<h3 id="编辑新增节点脚本">编辑新增节点脚本</h3>
<pre><code class="language-bash">scp startnode1.sh   root@192.168.40.7:/bsn/quorum/fromscratch/

 vim startnode1.sh
..... paste below details
#!/bin/bash
PRIVATE_CONFIG=ignore nohup geth --datadir new-node-2 --nodiscover --verbosity 5 --networkid 31337 --raft --raftport 50001 --raftjoinexisting 2 --rpc --rpcaddr 0.0.0.0 --rpcport 22001 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3,quorum,raft --emitcheckpoints --port 21001 2&gt;&gt;node2.log &amp;

 ./startnode1.sh
</code></pre>
<p>此时去192.168.40.6上查看节点状态显示为true</p>
<h3 id="可选static-nodesjson与所有其他连锁店参与者共享新的">可选：static-nodes.json与所有其他连锁店参与者共享新的</h3>
<pre><code class="language-bash">cp new-node-2/static-nodes.json root@192.168.40.6:/bsn/quorum/fromscratch/new-node-1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux 条件判断]]></title>
        <id>https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/</id>
        <link href="https://chriswsq.github.io/post/linux-tiao-jian-pan-duan/">
        </link>
        <updated>2020-12-03T03:20:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-if-结构">1. if 结构</h2>
<p>if 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<pre><code class="language-bash">if commands; then
  commands
[elif commands; then
  commands...]
[else
  commands]
fi
</code></pre>
<p>这个命令分成三个部分：if、elif和else。其中，后两个部分是可选的。</p>
<p>if 关键字后面是主要的判断条件，elif用来添加在主条件不成立时的其他判断条件，else则是所有条件都不成立时要执行的部分。</p>
<pre><code class="language-bash">if test $USER = &quot;foo&quot;; then
  echo &quot;Hello foo.&quot;
else
  echo &quot;You are not foo.&quot;
fi
</code></pre>
<p>上面的例子中，判断条件是环境变量$USER是否等于foo，如果等于就输出Hello foo.，否则输出其他内容。</p>
<p>if和then写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<pre><code class="language-bash">if true
then
  echo 'hello world'
fi

if false
then
  echo 'it is false' # 本行不会执行
fi
</code></pre>
<p>上面的例子中，true和false是两个特殊命令，前者代表操作成功，后者代表操作失败。if true意味着命令部分总是会执行，if false意味着命令部分永远不会执行。</p>
<p>除了多行的写法，if结构也可以写成单行。</p>
<pre><code class="language-bash">$ if true; then echo 'hello world'; fi
hello world

$ if false; then echo &quot;It's true.&quot;; fi
</code></pre>
<p>注意，if关键字后面也可以是一条命令，该条命令执行成功（返回值0），就意味着判断条件成立。</p>
<pre><code class="language-bash">$ if echo 'hi'; then echo 'hello world'; fi
hi
hello world
</code></pre>
<p>上面命令中，if后面是一条命令echo 'hi'。该命令会执行，如果返回值是0，则执行then的部分。</p>
<p>if后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回0，就会执行then的部分。</p>
<pre><code class="language-bash">$ if false; true; then echo 'hello world'; fi
hello world
</code></pre>
<p>上面例子中，if后面有两条命令（false;true;），第二条命令（true）决定了then的部分是否会执行。</p>
<p>elif部分可以有多个。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
if [ &quot;$character&quot; = &quot;1&quot; ]; then
    echo 1
elif [ &quot;$character&quot; = &quot;2&quot; ]; then
    echo 2
elif [ &quot;$character&quot; = &quot;3&quot; ]; then
    echo 3
else
    echo 输入不符合要求
fi
</code></pre>
<p>上面例子中，如果用户输入3，就会连续判断3次。</p>
<h2 id="2-test-命令">2. test 命令</h2>
<p>if结构的判断条件，一般使用test命令，有三种形式。</p>
<pre><code class="language-bash"># 写法一
test expression

# 写法二
[ expression ]

# 写法三
[[ expression ]]
</code></pre>
<p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的expression是一个表达式。这个表达式为真，test命令执行成功（返回值为0）；表达式为伪，test命令执行失败（返回值为1）。注意，第二种和第三种写法，[和]与内部的表达式之间必须有空格。</p>
<pre><code class="language-bash">$ test -f /etc/hosts
$ echo $?
0

$ [ -f /etc/hosts ]
$  echo $?
0
</code></pre>
<p>上面的例子中，test命令采用两种写法，判断/etc/hosts文件是否存在，这两种写法是等价的。命令执行后，返回值为0，表示该文件确实存在。</p>
<p>实际上，[这个字符是test命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把test命令的三种形式，用在if结构中，判断一个文件是否存在。</p>
<pre><code class="language-bash"># 写法一
if test -e /tmp/foo.txt ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法二
if [ -e /tmp/foo.txt ] ; then
  echo &quot;Found foo.txt&quot;
fi

# 写法三
if [[ -e /tmp/foo.txt ]] ; then
  echo &quot;Found foo.txt&quot;
fi
</code></pre>
<h2 id="3-判断表达式">3. 判断表达式</h2>
<p>if关键字后面，跟的是一个命令。这个命令可以是test命令，也可以是其他命令。命令的返回值为0表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="31-文件判断">3.1 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li>[ -a file ]：如果 file 存在，则为true。</li>
<li>[ -b file ]：如果 file 存在并且是一个块（设备）文件，则为true。</li>
<li>[ -c file ]：如果 file 存在并且是一个字符（设备）文件，则为true。</li>
<li>[ -d file ]：如果 file 存在并且是一个目录，则为true。</li>
<li>[ -e file ]：如果 file 存在，则为true。</li>
<li>[ -f file ]：如果 file 存在并且是一个普通文件，则为true。</li>
<li>[ -g file ]：如果 file 存在并且设置了组 ID，则为true。</li>
<li>[ -G file ]：如果 file 存在并且属于有效的组 ID，则为true。</li>
<li>[ -h file ]：如果 file 存在并且是符号链接，则为true。</li>
<li>[ -k file ]：如果 file 存在并且设置了它的“sticky bit”，则为true。</li>
<li>[ -L file ]：如果 file 存在并且是一个符号链接，则为true。</li>
<li>[ -N file ]：如果 file 存在并且自上次读取后已被修改，则为true。</li>
<li>[ -O file ]：如果 file 存在并且属于有效的用户 ID，则为true。</li>
<li>[ -p file ]：如果 file 存在并且是一个命名管道，则为true。</li>
<li>[ -r file ]：如果 file 存在并且可读（当前用户有可读权限），则为true。</li>
<li>[ -s file ]：如果 file 存在且其长度大于零，则为true。</li>
<li>[ -S file ]：如果 file 存在且是一个网络 socket，则为true。</li>
<li>[ -t fd ]：如果 fd 是一个文件描述符，并且重定向到终端，则为true。 这可以用来判断是否重定向了标准输入／输出错误。</li>
<li>[ -u file ]：如果 file 存在并且设置了 setuid 位，则为true。</li>
<li>[ -w file ]：如果 file 存在并且可写（当前用户拥有可写权限），则为true。</li>
<li>[ -x file ]：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为true。</li>
<li>[ file1 -nt file2 ]：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为true。</li>
<li>[ file1 -ot file2 ]：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为true。</li>
<li>[ FILE1 -ef FILE2 ]：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为true。<br>
下面是一个示例。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

FILE=~/.bashrc

if [ -e &quot;$FILE&quot; ]; then
  if [ -f &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a regular file.&quot;
  fi
  if [ -d &quot;$FILE&quot; ]; then
    echo &quot;$FILE is a directory.&quot;
  fi
  if [ -r &quot;$FILE&quot; ]; then
    echo &quot;$FILE is readable.&quot;
  fi
  if [ -w &quot;$FILE&quot; ]; then
    echo &quot;$FILE is writable.&quot;
  fi
  if [ -x &quot;$FILE&quot; ]; then
    echo &quot;$FILE is executable/searchable.&quot;
  fi
else
  echo &quot;$FILE does not exist&quot;
  exit 1
fi
</code></pre>
<p>上面代码中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>I</mi><mi>L</mi><mi>E</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">放</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">双</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">防</mi><mi mathvariant="normal">止</mi></mrow><annotation encoding="application/x-tex">FILE要放在双引号之中。这样可以防止</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">防</span><span class="mord cjk_fallback">止</span></span></span></span>FILE为空，因为这时[ -e ]会判断为真。而放在双引号之中，返回的就总是一个空字符串，[ -e &quot;&quot; ]会判断为伪。</p>
<h3 id="32-字符串判断">3.2 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li>[ string ]：如果string不为空（长度大于0），则判断为真。</li>
<li>[ -n string ]：如果字符串string的长度大于零，则判断为真。</li>
<li>[ -z string ]：如果字符串string的长度为零，则判断为真。</li>
<li>[ string1 = string2 ]：如果string1和string2相同，则判断为真。</li>
<li>[ string1 == string2 ] 等同于[ string1 = string2 ]。</li>
<li>[ string1 != string2 ]：如果string1和string2不相同，则判断为真。</li>
<li>[ string1 '&gt;' string2 ]：如果按照字典顺序string1排列在string2之后，则判断为真。</li>
<li>[ string1 '&lt;' string2 ]：如果按照字典顺序string1排列在string2之前，则判断为真。<br>
注意，test命令内部的&gt;和&lt;，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。</li>
</ul>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#!/bin/bash

ANSWER=maybe

if [ -z &quot;$ANSWER&quot; ]; then
  echo &quot;There is no answer.&quot; &gt;&amp;2
  exit 1
fi
if [ &quot;$ANSWER&quot; = &quot;yes&quot; ]; then
  echo &quot;The answer is YES.&quot;
elif [ &quot;$ANSWER&quot; = &quot;no&quot; ]; then
  echo &quot;The answer is NO.&quot;
elif [ &quot;$ANSWER&quot; = &quot;maybe&quot; ]; then
  echo &quot;The answer is MAYBE.&quot;
else
  echo &quot;The answer is UNKNOWN.&quot;
fi
</code></pre>
<p>上面代码中，首先确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>N</mi><mi>S</mi><mi>W</mi><mi>E</mi><mi>R</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">终</mi><mi mathvariant="normal">止</mi><mi mathvariant="normal">脚</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">退</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">为</mi><mn>1</mn><mi mathvariant="normal">。</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi>T</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>i</mi><mi>s</mi><mi>n</mi><mi>o</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">准</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">息</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">常</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi></mrow><annotation encoding="application/x-tex">ANSWER字符串是否为空。如果为空，就终止脚本，并把退出状态设为1。注意，这里的echo命令把错误信息There is no answer.重定向到标准错误，这是处理错误信息的常用方法。如果</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">终</span><span class="mord cjk_fallback">止</span><span class="mord cjk_fallback">脚</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">退</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">准</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">常</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span></span></span></span>ANSWER字符串不为空，就判断它的值是否等于yes、no或者maybe。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如[ -n &quot;$COUNT&quot; ]，否则变量替换成字符串以后，test命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成[ -n ]，这时会判断为真。如果放在双引号之中，[ -n &quot;&quot; ]就判断为伪。</p>
<h3 id="33-整数判断">3.3 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li>[ integer1 -eq integer2 ]：如果integer1等于integer2，则为true。</li>
<li>[ integer1 -ne integer2 ]：如果integer1不等于integer2，则为true。</li>
<li>[ integer1 -le integer2 ]：如果integer1小于或等于integer2，则为true。</li>
<li>[ integer1 -lt integer2 ]：如果integer1小于integer2，则为true。</li>
<li>[ integer1 -ge integer2 ]：如果integer1大于或等于integer2，则为true。</li>
<li>[ integer1 -gt integer2 ]：如果integer1大于integer2，则为true。<br>
下面是一个用法的例子。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [ -z &quot;$INT&quot; ]; then
  echo &quot;INT is empty.&quot; &gt;&amp;2
  exit 1
fi
if [ $INT -eq 0 ]; then
  echo &quot;INT is zero.&quot;
else
  if [ $INT -lt 0 ]; then
    echo &quot;INT is negative.&quot;
  else
    echo &quot;INT is positive.&quot;
  fi
  if [ $((INT % 2)) -eq 0 ]; then
    echo &quot;INT is even.&quot;
  else
    echo &quot;INT is odd.&quot;
  fi
fi
</code></pre>
<p>上面例子中，先判断变量$INT是否为空，然后判断是否为0，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="34-正则判断">3.4 正则判断</h3>
<p>[[ expression ]]这种判断形式，支持正则表达式。</p>
<pre><code class="language-bash">[[ string1 =~ regex ]]
</code></pre>
<p>上面的语法中，regex是一个正则表示式，=~是正则比较运算符。</p>
<p>下面是一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  echo &quot;INT is an integer.&quot;
  exit 0
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面代码中，先判断变量INT的字符串形式，是否满足^-?[0-9]+$的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="35-test-判断的逻辑运算">3.5 test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个test判断表达式结合起来，创造更复杂的判断。三种逻辑运算AND，OR，和NOT，都有自己的专用符号。</p>
<ul>
<li>AND运算：符号&amp;&amp;，也可使用参数-a。</li>
<li>OR运算：符号||，也可使用参数-o。</li>
<li>NOT运算：符号!。<br>
下面是一个AND的例子，判断整数是否在某个范围之内。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

MIN_VAL=1
MAX_VAL=100

INT=50

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if [[ $INT -ge $MIN_VAL &amp;&amp; $INT -le $MAX_VAL ]]; then
    echo &quot;$INT is within $MIN_VAL to $MAX_VAL.&quot;
  else
    echo &quot;$INT is out of range.&quot;
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>上面例子中，&amp;&amp;用来连接两个判断条件：大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>I</mi><msub><mi>N</mi><mi>V</mi></msub><mi>A</mi><mi>L</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">MIN_VAL，并且小于等于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span></span></span></span>MAX_VAL。</p>
<p>使用否定操作符!时，最好用圆括号确定转义的范围。</p>
<pre><code class="language-bash">if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then
    echo &quot;$INT is outside $MIN_VAL to $MAX_VAL.&quot;
else
    echo &quot;$INT is in range.&quot;
fi
</code></pre>
<p>上面例子中，test命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="36-算术判断">3.6 算术判断</h3>
<p>Bash 还提供了((...))作为算术条件，进行算术运算的判断。</p>
<pre><code class="language-bash">if ((3 &gt; 2)); then
  echo &quot;true&quot;
fi
</code></pre>
<p>上面代码执行后，会打印出true。</p>
<p>注意，算术判断不需要使用test命令，而是直接使用((...))结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<pre><code class="language-bash">$ if ((1)); then echo &quot;It is true.&quot;; fi
It is true.
$ if ((0)); then echo &quot;It is true.&quot;; else echo &quot;it is false.&quot;; fi
It is false.
</code></pre>
<p>上面例子中，((1))表示判断成立，((0))表示判断不成立。</p>
<p>算术条件((...))也可以用于变量赋值。</p>
<pre><code class="language-bash">$ if (( foo = 5 ));then echo &quot;foo is $foo&quot;; fi
foo is 5
</code></pre>
<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
<pre><code class="language-bash">$ if (( foo = 0 ));then echo &quot;It is true.&quot;;else echo &quot;It is false.&quot;; fi
It is false.
</code></pre>
<p>下面是用算术条件改写的数值判断脚本。</p>
<pre><code class="language-bash">#!/bin/bash

INT=-5

if [[ &quot;$INT&quot; =~ ^-?[0-9]+$ ]]; then
  if ((INT == 0)); then
    echo &quot;INT is zero.&quot;
  else
    if ((INT &lt; 0)); then
      echo &quot;INT is negative.&quot;
    else
      echo &quot;INT is positive.&quot;
    fi
    if (( ((INT % 2)) == 0)); then
      echo &quot;INT is even.&quot;
    else
      echo &quot;INT is odd.&quot;
    fi
  fi
else
  echo &quot;INT is not an integer.&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<p>只要是算术表达式，都能用于((...))语法，详见《Bash 的算术运算》一章。</p>
<h3 id="37-普通命令的逻辑运算">3.7 普通命令的逻辑运算</h3>
<p>如果if结构使用的不是test命令，而是普通命令，比如上一节的((...))算术运算，或者test命令与普通命令混用，那么可以使用 Bash 的命令控制操作符&amp;&amp;（AND）和||（OR），进行多个命令的逻辑运算。</p>
<pre><code class="language-bash">$ command1 &amp;&amp; command2
$ command1 || command2
</code></pre>
<p>对于&amp;&amp;操作符，先执行command1，只有command1执行成功后， 才会执行command2。对于||操作符，先执行command1，只有command1执行失败后， 才会执行command2。</p>
<pre><code class="language-bash">$ mkdir temp &amp;&amp; cd temp
</code></pre>
<p>上面的命令会创建一个名为temp的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<pre><code class="language-bash">$ [ -d temp ] || mkdir temp
</code></pre>
<p>上面的命令会测试目录temp是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<pre><code class="language-bash">[ ! -d temp ] &amp;&amp; exit 1
</code></pre>
<p>上面的命令中，如果temp子目录不存在，脚本会终止，并且返回值为1。</p>
<p>下面就是if与&amp;&amp;结合使用的写法。</p>
<pre><code class="language-bash">if [ condition ] &amp;&amp; [ condition ]; then
  command
fi
</code></pre>
<p>下面是一个示例。</p>
<pre><code class="language-bash">#! /bin/bash

filename=$1
word1=$2
word2=$3

if grep $word1 $filename &amp;&amp; grep $word2 $filename
then
  echo &quot;$word1 and $word2 are both in $filename.&quot;
fi
</code></pre>
<p>上面的例子只有在指定文件里面，同时存在搜索词word1和word2，就会执行if的命令部分。</p>
<p>下面的示例演示如何将一个&amp;&amp;判断表达式，改写成对应的if结构。</p>
<pre><code class="language-bash">[[ -d &quot;$dir_name&quot; ]] &amp;&amp; cd &quot;$dir_name&quot; &amp;&amp; rm *

# 等同于

if [[ ! -d &quot;$dir_name&quot; ]]; then
  echo &quot;No such directory: '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! cd &quot;$dir_name&quot;; then
  echo &quot;Cannot cd to '$dir_name'&quot; &gt;&amp;2
  exit 1
fi
if ! rm *; then
  echo &quot;File deletion failed. Check results&quot; &gt;&amp;2
  exit 1
fi
</code></pre>
<h2 id="4-case-结构">4. case 结构</h2>
<p>case结构用于多值判断，可以为每个值指定对应的命令，跟包含多个elif的if结构等价，但是语义更好。它的语法如下。</p>
<pre><code class="language-bash">case expression in
  pattern )
    commands ;;
  pattern )
    commands ;;
  ...
esac
</code></pre>
<p>上面代码中，expression是一个表达式，pattern是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（;）结尾。</p>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个1到3之间的数字（包含两端）&gt; &quot;
read character
case $character in
  1 ) echo 1
    ;;
  2 ) echo 2
    ;;
  3 ) echo 3
    ;;
  * ) echo 输入不符合要求
esac
</code></pre>
<p>上面例子中，最后一条匹配语句的模式是*，这个通配符可以匹配其他字符和没有输入字符的情况，类似if的else部分。</p>
<p>下面是另一个例子。</p>
<pre><code class="language-bash">#!/bin/bash

OS=$(uname -s)

case &quot;$OS&quot; in
  FreeBSD) echo &quot;This is FreeBSD&quot; ;;
  Darwin) echo &quot;This is Mac OSX&quot; ;;
  AIX) echo &quot;This is AIX&quot; ;;
  Minix) echo &quot;This is Minix&quot; ;;
  Linux) echo &quot;This is Linux&quot; ;;
  *) echo &quot;Failed to identify this OS&quot; ;;
esac
</code></pre>
<p>上面的例子判断当前是什么操作系统。</p>
<p>case的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li>a)：匹配a。</li>
<li>a|b)：匹配a或b。</li>
<li>[[:alpha:]])：匹配单个字母。</li>
<li>???)：匹配3个字符的单词。</li>
<li>*.txt)：匹配.txt结尾。</li>
<li>*)：匹配任意输入，通过作为case结构的最后一个模式。</li>
</ul>
<pre><code class="language-bash">#!/bin/bash

echo -n &quot;输入一个字母或数字 &gt; &quot;
read character
case $character in
  [[:lower:]] | [[:upper:]] ) echo &quot;输入了字母 $character&quot;
                              ;;
  [0-9] )                     echo &quot;输入了数字 $character&quot;
                              ;;
  * )                         echo &quot;输入不符合要求&quot;
esac
</code></pre>
<p>上面例子中，使用通配符[[:lower:]] | [[:upper:]]匹配字母，[0-9]匹配数字。</p>
<p>Bash 4.0之前，case结构只能匹配一个条件，然后就会退出case结构。Bash 4.0之后，允许匹配多个条件，这时可以用;;&amp;终止每个条件块。</p>
<pre><code class="language-bash">#!/bin/bash
# test.sh

read -n 1 -p &quot;Type a character &gt; &quot;
echo
case $REPLY in
  [[:upper:]])    echo &quot;'$REPLY' is upper case.&quot; ;;&amp;
  [[:lower:]])    echo &quot;'$REPLY' is lower case.&quot; ;;&amp;
  [[:alpha:]])    echo &quot;'$REPLY' is alphabetic.&quot; ;;&amp;
  [[:digit:]])    echo &quot;'$REPLY' is a digit.&quot; ;;&amp;
  [[:graph:]])    echo &quot;'$REPLY' is a visible character.&quot; ;;&amp;
  [[:punct:]])    echo &quot;'$REPLY' is a punctuation symbol.&quot; ;;&amp;
  [[:space:]])    echo &quot;'$REPLY' is a whitespace character.&quot; ;;&amp;
  [[:xdigit:]])   echo &quot;'$REPLY' is a hexadecimal digit.&quot; ;;&amp;
esac
</code></pre>
<p>执行上面的脚本，会得到下面的结果。</p>
<pre><code class="language-bash">$ test.sh
Type a character &gt; a
'a' is lower case.
'a' is alphabetic.
'a' is a visible character.
'a' is a hexadecimal digit.
</code></pre>
<p>可以看到条件语句结尾添加了;;&amp;以后，在匹配一个条件之后，并没有退出case结构，而是继续判断下一个条件。</p>
<h2 id="5-参考链接">5. 参考链接</h2>
<p><a href="https://wangdoc.com/bash/condition.html">转载自</a><br>
<a href="http://linuxcommand.org/tlcl.php">The Linux Command Line</a>, William Shotts</p>
]]></content>
    </entry>
</feed>